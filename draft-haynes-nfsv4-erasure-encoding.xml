<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt'?>

<rfc
   category='std'
   docName='draft-haynes-nfsv4-erasure-encoding-VERSIONVAR'
   ipr='trust200902'
   obsoletes=''
   scripts='Common,Latin'
   sortRefs='true'
   submissionType='IETF'
   symRefs='true'
   tocDepth='3'
   tocInclude='true'
   version='3'
   consensus='true'
   xml:lang='en'>

  <front>
    <title abbrev='erasure encoding'>
      Erasure Encoding of Files in NFSv4.2
    </title>
    <seriesInfo name='Internet-Draft' value='draft-haynes-nfsv4-erasure-encoding-VERSIONVAR'/>
    <author fullname='Thomas Haynes' initials='T.' surname='Haynes'>
      <organization abbrev='Hammerspace'>Hammerspace</organization>
      <address>
        <email>loghyr@gmail.com</email>
      </address>
    </author>
    <date year='YEARVAR' month='MONTHVAR' day='DAYVAR'/>
    <area>Transport</area>
    <workgroup>Network File System Version 4</workgroup>
    <keyword>NFSv4</keyword>
    <abstract>
      <t>
        Parallel NFS (pNFS) allows a separation between the metadata (onto
        a metadata server) and data (onto a storage device) for a file.
        The Flexible File Version 2 Layout Type is defined in this document
        as an extension to pNFS that allows the use of storage devices that
        require only a limited degree of interaction with the metadata
        server and use already-existing protocols.  Data replication is
        also added to provide integrity.
      </t>
    </abstract>

    <note removeInRFC='true'>
      <t>
        Discussion of this draft takes place
        on the NFSv4 working group mailing list (nfsv4@ietf.org),
        which is archived at
        <eref target='https://mailarchive.ietf.org/arch/browse/nfsv4/'/>.
        Working Group information can be found at
        <eref target='https://datatracker.ietf.org/wg/nfsv4/about/'/>.
      </t>
    </note>

    <note removeInRFC='true'>
      <t>
        This draft starts sparse and will be filled in as details are
        ironed out.
        In the first draft, we simply explain the
        semantics changes. As these are accepted by the knowledgeable reviewers,
        we will flesh out the operation description sections to include sub-sections more
        akin to 18.32.3 and 18.32.4 of <xref target='RFC8881' />.
      </t>
      <t>
        Except where called out, all the semantics of the Flexible File Version 1 Layout
        Type presented in <xref target='RFC8435' /> still apply. This new
        version extends it and does not replace it.
      </t>
    </note>
  </front>

  <middle>

    <section anchor='sec_intro' numbered='true' removeInRFC='false' toc='default'>
      <name>Introduction</name>
      <t>
        In Parallel NFS (pNFS) (see Section 12 of
        <xref target='RFC8881' />),
        the metadata server returns layout type
        structures that describe where file data is located.  There are
        different layout types for different storage systems and methods
        of arranging data on storage devices.  <xref target='RFC8435' />
        defined the Flexible
        File Version 1 Layout Type used with file-based data servers that are
        accessed using the NFS protocols: NFSv3 <xref target='RFC1813' />,
        NFSv4.0 <xref target='RFC7530' />, NFSv4.1 <xref target='RFC8881' />, and
        NFSv4.2 <xref target='RFC7862' />.
      </t>

      <t>
        The Client Side Mirroring (see Section 8 of <xref target='RFC8435' />), introduced with the first
        version of the Flexible File Layout Type, provides for replication
        of data but does not provide for integrity of data. In the event
        of an error, an user would be able to repair the file by silvering
        the mirror contents. I.e., they would pick one of the mirror
        instances and replicate it to the other instance locations.
      </t>

      <t>
        However, lacking integrity checks, silent corruptions are not able
        to be detected and the choice of what constitutes the good copy
        is difficult.  This document updates the Flexible File Layout Type
        to version 2 by providing data integrity for erasure encoding. Data
        blocks are transformed into a header and a chunk.
        It introduces a new operation ROLLBACK_OPEN that allow the client to maintain
        rollbacks to the data file by creating a per client file to store chunk
        modifications. The client writes chunks to the client file and then
        atomically exchanges the chunks in the client file with
        those in the data file. In case of write holes, it can rollback
        the chunks. It can remove the client file with ROLLBACK_CLOSE.
        Both ROLLBACK_OPEN and ROLLBACK_LIST can be used by the client or metadata server
        to recover after a client restart or a client which has
        permanently gone away.
      </t>

      <t>
        Using the process detailed in <xref target='RFC8178' format='default'
        sectionFormat='of'/>, the revisions in this document become an
        extension of NFSv4.2 <xref target='RFC7862' format='default'
        sectionFormat='of'/>. They are built on top of the external data
        representation (XDR) <xref target='RFC4506' format='default'
        sectionFormat='of'/> generated from <xref target='RFC7863' />.
      </t>

      <section anchor='sec_defs' numbered='true' removeInRFC='false' toc='default'>
        <name>Definitions</name>
        <dl newline='false' spacing='normal'>
          <dt>chunk:</dt>
          <dd>
            One of the resulting chunks to be exchanged with a data
            server after a transformation has been applied to
            a data block. The resulting chunk
            may be a different size than the data block.
          </dd>

          <dt>Client Side Mirroring:</dt>
          <dd>
            A file based replication method where copies are maintained
            in parallel.
          </dd>

          <dt>data block:</dt>
          <dd>
            A block of data in the client's cache for a file.
          </dd>

          <dt>data file:</dt>
          <dd>
            The data portion of the file, stored on the data server.
          </dd>

          <dt>Erasure Encoding:</dt>
          <dd>
            A data protection scheme where a block of data is replicated
            into fragments and additional redundant fragments are added
            to achieve parity. The new chunks are stored in different
            locations.
          </dd>

          <dt>Client Side Erasure Encoding:</dt>
          <dd>
            A file based integrity method where copies are maintained
            in parallel.
          </dd>

          <dt>integrity of data:</dt>
          <dd>
            Data integrity refers to the accuracy, consistency, and
            reliability of data throughout its life cycle.
          </dd>

          <dt>metadata file:</dt>
          <dd>
            The metadata portion of the file, stored on the metadata server.
          </dd>

          <dt>client file:</dt>
          <dd>
            A temporary file established on the data server by the
            client to allow chunks to be swapped with the orginal file.
          </dd>

          <dt>replication of data:</dt>
          <dd>
            Data replication is making and storing multiple copies
            of data in different locations.
          </dd>

          <dt>write hole:</dt>
          <dd>
            A write hole is a data corruption scenario where either
            two clients are trying to write to the same chunk or
            one client is overwriting an existing chunk of data.
          </dd>
        </dl>
      </section>

      <section numbered='true' removeInRFC='false' toc='default'>
        <name>Requirements Language</name>
        <t>
          The key words '<bcp14>MUST</bcp14>', '<bcp14>MUST NOT</bcp14>',
          '<bcp14>REQUIRED</bcp14>', '<bcp14>SHALL</bcp14>', '<bcp14>SHALL
          NOT</bcp14>', '<bcp14>SHOULD</bcp14>', '<bcp14>SHOULD NOT</bcp14>',
          '<bcp14>RECOMMENDED</bcp14>', '<bcp14>NOT RECOMMENDED</bcp14>',
          '<bcp14>MAY</bcp14>', and '<bcp14>OPTIONAL</bcp14>' in this
          document are to be interpreted as described in BCP 14 <xref
          target='RFC2119' /> <xref target='RFC8174' /> when,
          and only when, they appear in all capitals, as shown here.
        </t>
      </section>
    </section>

    <section numbered='true' removeInRFC='false' toc='default'>
      <name>Flexible File Version 2 Layout Type</name>
      <t>
        In order to introduce erasure encoding to pNFS, a new layout type
        of LAYOUT4_FLEX_FILES_V2 needs to be defined.  While we could
        define a new layout type per erasure encoding type, there exist
        use cases where multiple erasure encoding types exist in the same layout.
      </t>
      <t>
        The original layouttype4 introduced in <xref target='RFC8881' />
        is modified to as in <xref target='code_layout4' />.
      </t>

      <figure anchor='code_layout4'>
        <sourcecode type='xdr'>
 enum layouttype4 {
     LAYOUT4_NFSV4_1_FILES   = 1,
     LAYOUT4_OSD2_OBJECTS    = 2,
     LAYOUT4_BLOCK_VOLUME    = 3,
     LAYOUT4_FLEX_FILES      = 4,
     LAYOUT4_FLEX_FILES_V2   = 5
 };

 struct layout_content4 {
     layouttype4             loc_type;
     opaque                  loc_body&lt;&gt;;
 };

 struct layout4 {
     offset4                 lo_offset;
     length4                 lo_length;
     layoutiomode4           lo_iomode;
     layout_content4         lo_content;
 };
        </sourcecode>
      </figure>

      <t>
        This document defines structures associated with the layouttype4
        value LAYOUT4_FLEX_FILES_V2.  <xref target='RFC8881' format='default'
        sectionFormat='of' /> specifies the loc_body structure as an XDR
        type 'opaque'.  The opaque layout is uninterpreted by the generic
        pNFS client layers but is interpreted by the Flexible File Version 2 Layout
        Type implementation.  This section defines the structure of this
        otherwise opaque value, ffv2_layout4.
      </t>

      <section anchor='ffv2_encoding_type4' numbered='true' removeInRFC='false' toc='default'>
        <name>ffv2_encoding_type4</name>

        <figure anchor='code_ffv2_encoding_type4'>
          <sourcecode type='xdr'>
/// enum ffv2_encoding_type4 {
///     FFV2_ENCODING_MIRRORED       = 0x1;
/// };
          </sourcecode>
        </figure>

        <t>
          The ffv2_encoding_type4 (see <xref target='code_ffv2_encoding_type4' />)
          encompasses a new IANA registry for 'Flex Files V2 Erasure
          Encoding Type Registry' (see <xref target='sec_iana_encoding' />).
          I.e., instead of defining a new Layout Type for each
          Erasure Encoding, we define a new Erasure Encoding Type.
          Except for FFV2_ENCODING_MIRRORED, each of the types
          is expected to employ the new operations in this document.
        </t>

        <t>
          FFV2_ENCODING_MIRRORED offers replication of data and
          not integrity of data. As such, it does not need operations
          like CHUNK_WRITE (see <xref target='CHUNK_WRITE' />).
        </t>
      </section>

      <section anchor='ss_write_mirror' numbered='true' removeInRFC='false' toc='default'>
        <name>To be done later</name>
      </section>

      <section anchor='ffv2_flags4' numbered='true' removeInRFC='false' toc='default'>
        <name>ffv2_flags4</name>
        <figure anchor='code_ffv2_flags4'>
          <sourcecode type='xdr'>
/// const FFV2_FLAGS_NO_LAYOUTCOMMIT   = 0x00000001;
/// const FFV2_FLAGS_NO_IO_THRU_MDS    = 0x00000002;
/// const FFV2_FLAGS_NO_READ_IO        = 0x00000004;
/// const FFV2_FLAGS_WRITE_ONE_MIRROR  = 0x00000008;
/// const FFV2_FLAGS_ONLY_ONE_WRITER   = 0x00000010;
/// typedef uint32_t ffv2_flags4;
          </sourcecode>
        </figure>

        <t>
          The ff2_flags4 in <xref target='code_ffv2_flags4' /> is a bitmap
          that allows the metadata server to inform
          the client of particular conditions that may result from more or
          less tight coupling of the storage devices.
        </t>

        <dl newline='false' spacing='normal'>
          <dt>FFV2_FLAGS_NO_LAYOUTCOMMIT:</dt>
          <dd>
             can be set to indicate that the client is not required to
             send LAYOUTCOMMIT to the metadata server.
          </dd>

          <dt>FFV2_FLAGS_NO_IO_THRU_MDS:</dt>
          <dd>
             can be set to indicate that the client should not send I/O
             operations to the metadata server.  That is, even if the
             client could determine that there was a network disconnect
             to a storage device, the client should not try to proxy the
             I/O through the metadata server.
          </dd>

          <dt>FFV2_FLAGS_NO_READ_IO:</dt>
          <dd>
             can be set to indicate that the client should not send READ
             requests with the layouts of iomode LAYOUTIOMODE4_RW.  Instead,
             it should request a layout of iomode LAYOUTIOMODE4_READ from
             the metadata server.
          </dd>

          <dt>FFV2_FLAGS_WRITE_ONE_MIRROR:</dt>
          <dd>
             can be set to indicate that the client only needs to update
             one of the mirrors (see <xref target='ss_write_mirror' />).
          </dd>

          <dt>FFV2_FLAGS_ONLY_ONE_WRITER:</dt>
          <dd>
            can be set to indicate that the client only needs to use
            CHUNK_WRITE_SWAP to update the chunks in the data file. I.e.,
            keep the ability to rollback in case of a write hole
            caused by overwriting. If this flag is not set, then the
            client <bcp14>MUST</bcp14> write chunks with CHUNK_WRITE_SWAP_GUARD
            in order to prevent collision across the data servers.
          </dd>
        </dl>
      </section>

      <section anchor='ffv2_file_info4' numbered='true' removeInRFC='false' toc='default'>
        <name>ffv2_file_info4</name>
        <figure anchor='code_ffv2_file_info4'>
          <sourcecode type='xdr'>
/// struct ffv2_file_info4 {
///     stateid4                fffi_stateid;
///     nfs_fh4                 fffi_fh_vers;
/// };
          </sourcecode>
        </figure>
        <t>
          The ffv2_file_info4 is a new structure to help with
          the stateid issue discussed in Section 5.1
          of <xref target='RFC8435' />. I.e., in
          version 1 of the Flexible File Layout Type, there
          was the singleton ffds_stateid combined with the
          ffds_fh_vers array. I.e., each NFSv4 version has
          its own stateid. In <xref target='code_ffv2_file_info4' />,
          each NFSv4 filehandle has a one-to-one correspondence to a stateid.
        </t>
      </section>

      <section anchor='ffv2_ds_flags4' numbered='true' removeInRFC='false' toc='default'>
        <name>ffv2_ds_flags4</name>
        <figure anchor='code_ffv2_ds_flags4'>
          <sourcecode type='xdr'>
/// const FFV2_DS_FLAGS_ACTIVE        = 0x00000001;
/// const FFV2_DS_FLAGS_SPARE         = 0x00000002;
/// const FFV2_DS_FLAGS_PARITY        = 0x00000004;
/// const FFV2_DS_FLAGS_REPAIR        = 0x00000008;
/// typedef uint32_t            ffv2_ds_flags4;
          </sourcecode>
        </figure>
        <t>
          The ffv2_ds_flags4 (in <xref target='code_ffv2_ds_flags4' />) flags details
          the state of the data servers. With Erasure Encoding algorithms, there are both Systematic and Non-Systematic
          approaches. In the Systematic, the bits for integrity are placed amoungst the
          resulting transformed chunk. Such an implementation would typically see
          FFV2_DS_FLAGS_ACTIVE and FFV2_DS_FLAGS_SPARE data servers. The FFV2_DS_FLAGS_SPARE
          ones allow the client to repair a payload without enaging the metadata server.
          I.e., if one of the FFV2_DS_FLAGS_ACTIVE did not respond to a WRITE_BLOCK,
          the client could fail the chunk to the FFV2_DS_FLAGS_SPARE data server.
        </t>
        <t>
          With the Non-Systematic approach, the data and integrity live on different
          data servers. Such an implementation would typically see FFV2_DS_FLAGS_ACTIVE
          and FFV2_DS_FLAGS_PARITY data servers. If the implementation wanted to allow
          for local repair, it would also use FFV2_DS_FLAGS_SPARE.
        </t>
        <t>
          The FFV2_DS_FLAGS_REPAIR flag can be
          used by the metadata server to inform the client that the indicated
          data server is a replacement data server as far as existing data is
          concerned. The client <bcp14>MUST</bcp14> repair the file by using
          ROLLBACK_OPEN on the entire length of the file and both decoding the existing
          data from the file and recoding the new data on the indicated data
          server. Whilst all data servers <bcp14>MUST</bcp14> be reserved,
          only the data server(s) to be repaired <bcp14>MUST</bcp14> have the ROLLBACK_OPEN_SWAP
          operation applied. The remaining data servers can have their reservation
          files dropped via ROLLBACK_CLOSE.
        </t>
        <t>
          See  <xref target='Plank97' /> for further
          reference to storage layouts for encoding.
        </t>
      </section>

      <section anchor='ffv2_data_server4' numbered='true' removeInRFC='false' toc='default'>
        <name>ffv2_data_server4</name>
        <figure anchor='code_ffv2_data_server4'>
          <sourcecode type='xdr'>
/// struct ffv2_data_server4 {
///     deviceid4               ffds_deviceid;
///     uint32_t                ffds_efficiency;
///     ffv2_file_info4         ffds_file_info&lt;&gt;;
///     fattr4_owner            ffds_user;
///     fattr4_owner_group      ffds_group;
///     ffv2_ds_flags4          ffds_flags;
/// };
          </sourcecode>
        </figure>
        <t>
          The ffv2_data_server4 (in <xref target='code_ffv2_data_server4' />) describes
          a data file and how to access it via the different NFS protocols.
        </t>
      </section>

      <section anchor='ffv2_encoding_type_data4' numbered='true' removeInRFC='false' toc='default'>
        <name>ffv2_encoding_type_data4</name>
        <figure anchor='code_ffv2_encoding_type_data4'>
          <sourcecode type='xdr'>
/// union ffv2_encoding_type_data4 switch
///         (ffv2_encoding_type4 fetd_encoding) {
///     case FFV2_ENCODING_MIRRORED:
///         void;
/// };
          </sourcecode>
        </figure>
        <t>
          The ffv2_encoding_type_data4 (in <xref target='code_ffv2_encoding_type_data4' />) describes
          erasure encoding type specific fields. I.e., this is how the encoding type can
          communicate the need for counts of active, spare, parity, and repair types
          of chunks.
        </t>
      </section>

      <section anchor='ffv2_key4' numbered='true' removeInRFC='false' toc='default'>
        <name>ffv2_key4</name>
        <figure anchor='code_ffv2_key4'>
          <sourcecode type='xdr'>
/// typedef opaque ffv2_key4&lt;&gt;;
          </sourcecode>
        </figure>
        <t>
          The ffv2_key4 (in <xref target='code_ffv2_key4' />) is a secret key known
          only to the metadata server, data server, and client. In the event of
          either a data server restart or a dead client, it can be used to
          restablish a connection via ROLLBACK_OPEN_RECOVER.
        </t>
      </section>

      <section anchor='ffv2_mirror4' numbered='true' removeInRFC='false' toc='default'>
        <name>ffv2_mirror4</name>
        <figure anchor='code_ffv2_mirror4'>
          <sourcecode type='xdr'>
/// struct ffv2_mirror4 {
///     ffv2_encoding_type_data4 ffm_encoding_type_data;
///     ffv2_key4                ffm_key;
///     uint32_t                 ffm_client_id;
///     ffv2_data_server4        ffm_data_servers&lt;&gt;;
/// };
          </sourcecode>
        </figure>
        <t>
          The ffv2_mirror4 (in <xref target='code_ffv2_mirror4' />) describes
          the Flexible File Layout Version 2 specific fields. The ffm_key allows
          the client to access an already existing client file on the data servers
          and the ffm_client_id tells the client which id to use when interacting
          with the data servers.
        </t>
      </section>

      <section anchor='ffv2_layout4' numbered='true' removeInRFC='false' toc='default'>
        <name>ffv2_layout4</name>
        <figure anchor='code_ffv2_layout4'>
          <sourcecode type='xdr'>
/// struct ffv2_layout4 {
///     length4                 ffl_stripe_unit;
///     ffv2_mirror4            ffl_mirrors&lt;&gt;;
///     ffv2_flags4             ffl_flags;
///     uint32_t                ffl_stats_collect_hint;
/// };
          </sourcecode>
        </figure>
        <t>
          The ffv2_layout4 (in <xref target='code_ffv2_layout4' />) describes
          the Flexible File Layout Version 2.
        </t>
      </section>

      <section anchor='ffv2_layouthint4' numbered='true' removeInRFC='false' toc='default'>
        <name>ffv2_layouthint4</name>
        <figure anchor='code_ffv2_layouthint4'>
          <sourcecode type='xdr'>
/// union ffv2_mirrors_hint switch (ffv2_encoding_type4 ffmh_type) {
///     case FFV2_ENCODING_MIRRORED:
///         void;
/// };
///
/// struct ffv2_layouthint4 {
///     ffv2_encoding_type4 fflh_supported_types&lt;&gt;;
///     ffv2_mirrors_hint fflh_mirrors_hint;
/// };
          </sourcecode>
        </figure>
        <t>
          The ffv2_layouthint4 (in <xref target='code_ffv2_layouthint4' />) describes
          the layout_hint (see Section 5.12.4 of <xref target='RFC8881' />)
          that the client can provide to the metadata server.
        </t>
      </section>

      <section anchor='sec_mix_types' numbered='true' removeInRFC='false' toc='default'>
        <name>Mixing of Encoding Types</name>
        <t>
          Multiple encoding types can be present
          in a Flexible File Version 2 Layout Type layout.  The ffv2_layout4 has an array
          of ffv2_mirror4, each of which has a ffv2_encoding_type4.
          The main reason to allow for this is to provide for either the
          assimilation of a non-erasure encoded file to an erasure
          encoded file or the exporting of an erasure encoded file to
          a non-erasure encoded file.
        </t>
        <t>
          Assume there is an additional ffv2_encoding_type4 of
          FFV2_ENCODING_REED_SOLOMON and it needs 8 active chunks.
          The user wants to actively assimilate a regular
          file. As such, a layout might be as represented in <xref
          target='mixed_layout' />.  As this is an assimilation, most of
          the data reads will be satisfied by READ (see Section 18.22 of
          <xref target='RFC8881' />)
          calls to index 0. However, as this is also an active file,
          there could also be CHUNK_READ (see <xref target='CHUNK_READ' />)
          calls to the other indexes.
        </t>

        <figure anchor='mixed_layout'>
          <name>Example of Mixed Encoding Types in a Layout</name>
          <artwork>
         +---------------------------------------------------+
         | ffv2_layout4:                                     |
         +---------------------------------------------------+
         |     ffl_mirrors[0]:                               |
         |         ffm_data_servers:                         |
         |             ffv2_data_server4[0]                  |
         |                 ffds_flags: 0                     |
         |         ffm_encoding: FFV2_ENCODING_MIRRORED      |
         +---------------------------------------------------+
         |     ffl_mirrors[1]:                               |
         |         ffm_data_servers:                         |
         |             ffv2_data_server4[0]                  |
         |                 ffds_flags: FFV2_DS_FLAGS_ACTIVE  |
         |             ffv2_data_server4[1]                  |
         |                 ffds_flags: FFV2_DS_FLAGS_ACTIVE  |
         |             ffv2_data_server4[2]                  |
         |                 ffds_flags: FFV2_DS_FLAGS_ACTIVE  |
         |             ffv2_data_server4[3]                  |
         |                 ffds_flags: FFV2_DS_FLAGS_ACTIVE  |
         |             ffv2_data_server4[4]                  |
         |                 ffds_flags: FFV2_DS_FLAGS_PARITY  |
         |             ffv2_data_server4[5]                  |
         |                 ffds_flags: FFV2_DS_FLAGS_PARITY  |
         |             ffv2_data_server4[6]                  |
         |                 ffds_flags: FFV2_DS_FLAGS_SPARE   |
         |             ffv2_data_server4[7]                  |
         |                 ffds_flags: FFV2_DS_FLAGS_SPARE   |
         |     ffm_encoding: FFV2_ENCODING_REED_SOLOMON      |
         +---------------------------------------------------+
          </artwork>
        </figure>
        <t>
          When performing I/O via a FFV2_ENCODING_MIRRORED encoding
          type, the non-transformed data will be used, Whereas with
          other encoding types, a metadata header and transformed block will
          be sent. Further, when reading data from the instance files,
          the client <bcp14>MUST</bcp14> be prepared to have one of the
          encoding types supply data and the other type not to supply
          data. I.e., the CHUNK_READ call to the data servers in mirror 1
          might return rlr_eof set to true
          (see <xref target='code_CHUNK_READ4resok' />),
          which indicates that there is
          no data, where the READ call to the data server in mirror 0 might
          return eof to be false, which indicates that there is data. The
          client <bcp14>MUST</bcp14> determine that there is in fact data.
        </t>
        <t>
          An example use case is the active assimilation of a file to ensure
          integrity. As the client is helping to translated the file to
          the new encoding scheme, it is actively modifying the file. As
          such, it might be sequentially reading the file in order to
          translate. The READ calls to mirror 0  would be returning data
          and the CHUNK_READ calls to mirror 1 would not be returning data. As
          the client overwrites the file, the WRITE call and WRITE_SWAP_CHUNK call would have data
          sent to all of the data servers. Finally, if the client reads
          back a section which had been modified earlier, both
          the READ and CHUNK_READ calls would return data.
        </t>
      </section>
    </section>

    <section anchor='sec_NFSv42_ops_to_data_file' numbered='true' removeInRFC='false' toc='default'>
      <name>NFSv4.2 Operations Allowed to Data Files</name>
          <t>
            <cref anchor='AI42' source='TH'>
              In Flexible File Version 1 Layout Type, the emphasis was on
              NFSv3 DSes. We limited the operations that clients could
              send to data files to be COMMIT, READ, and WRITE. We
              further limited the MDS to GETATTR, SETATTR, CREATE,
              and REMOVE. (Funny enough, this is not mandated by
              <xref target='RFC8435' />.) We need to call this
              out in this draft and also we need to limit the
              NFSv4.2 operations. Besides the ones created here,
              consider: READ, WRITE, and COMMIT for mirroring types and
              ALLOCATE, CLONE, COPY, DEALLOCATE, GETFH, PUTFH,
              READ_PLUS, RESTOREFH, SAVEFH, SEEK, and SEQUENCE  for all types.
            </cref>
            <cref anchor='AI43' source='TH'>
              Of special merit is SETATTR. Do we want to allow the clients
              to be able to truncate the data files? Which also brings up
              DEALLOCATE. Perhaps we want CHUNK_DEALLOCATE? That way we
              can swap out chunks with the client file. CHUNK_DEALLOCATE_GUARD.
              Really need to determine capabilities of XFS swap!
            </cref>
          </t>
    </section>

    <section anchor='sec_erasure_encoding' numbered='true' removeInRFC='false' toc='default'>
      <name>Erasure Encoding</name>
      <t>
        Erasure Encoding takes a data block and transforms it to a payload to
        send to the data servers (see <xref target='encoding_transformation' />). It
        generates a metadata header and transformed block per data server. The header is metadata
        information for the transformed block. From now on, the metadata is
        simply referred to as the header and the transformed block as the
        chunk. The payload of a data block is the set of generated headers and chunks
        for that data block.
      </t>
      <t>
        The guard is an unique identifier generated by the client to
        describe the current write transaction (see <xref target='chunk_guard4' />).
        The intent is to have an unique and non-opauqe value for comparison.
        The payload_id describes the position within the payload.  Finally,
        the crc32 is the 32 bit crc calculation of the header (with the
        crc32 field being 0) and the chunk. By combining the two parts of
        the payload, integrity is ensured for both the parts.
      </t>
      <t>
        While the data block might have a length of 4kB, that does not
        necessarily mean that the length of the chunk
        is 4kB. That length is determined by the erasure encoding type
        algorithm. For example, Reed Solomon might have 4kB
        chunks with the data integrity being compromised by
        parity chunks. Another example would be the Mojette Transformation,
        which might have 1kB chunk lengths.
      </t>
      <t>
        The payload contains redundancy which will allow
        the erasure encoding type algorithm to repair
        chunks in the payload as it is transformed back to a data block (see
        <xref target='decoding_transformation' />).
        A payload is consistent when all of the contained headers
        share the same guard. It has integrity when it is consistent
        and the combinations of headers and chunks all pass the crc32 checks.
      </t>
      <t>
        The erasure encoding algorithm itelf might not be sufficient
        to detect errors in the chunks. The crc32 checks will allow
        the data server to detect chunks with issues and then the
        erasure decoding algorithm can reconstruct the missing chunk.
      </t>

      <section anchor='sec_encoding_transformation' numbered='true' removeInRFC='false' toc='default'>
        <name>Encoding a Data Block</name>

        <figure anchor='encoding_transformation'>
          <name>Encoding a Data Block</name>
          <artwork>
                  +-------------+
                  | data block  |
                  +-------+-----+
                          |
                          |
    +---------------------+-------------------------------+
    |            Erasure Encoding (Transform Forward)     |
    +---+----------------------+---------------------+----+
        |                      |                     |
        |                      |                     |
    +---+------------+     +---+------------+     +--+-------------+
    | HEADER         | ... | HEADER         | ... | HEADER         |
    +----------------+     +----------------+     +----------------+
    | guard:         | ... | guard:         | ... | guard:         |
    |   change_id: 3 | ... |   change_id: 3 | ... |   change_id: 3 |
    |   client_id: 6 | ... |   client_id: 6 | ... |   client_id: 6 |
    | payload_id : 0 | ... | payload_id : M | ... | payload_id : 5 |
    | crc32   :      | ... | crc32   :      | ... | crc32   :      |
    +----------------+     +----------------+     +----------------+
    | CHUNK          | ... | CHUNK          | ... | CHUNK          |
    +----------------+     +----------------+     +----------------+
    | data: ....     | ... | data: ....     | ... | data: ....     |
    +----------------+     +----------------+     +----------------+
      Data Server 1          Data Server N          Data Server 6
          </artwork>
        </figure>

        <t>
          Each data block of the file resident in the client's cache of the
          file will be encoded into N different payloads to be
          sent to the data servers as shown in <xref target='encoding_transformation' />.
          As CHUNK_WRITE (see <xref target='CHUNK_WRITE' />) can encode
          multiple write_chunk4 into a single transaction, a more accurate
          description of a CHUNK_WRITE might be as in <xref target='example_CHUNK_WRITE_args_1' />.
        </t>

        <figure anchor='example_CHUNK_WRITE_args_1'>
          <name>Example of CHUNK_WRITE_args</name>
          <artwork>
        +------------------------------------+
        | CHUNK_WRITEargs                    |
        +------------------------------------+
        | cwa_stateid: 0                     |
        | cwa_offset: 1                      |
        | cwa_stable: FILE_SYNC4             |
        | cwa_payload_id: 0                  |
        | cwa_owner:                         |
        |            co_guard:               |
        |                cg_change_id: 3     |
        |                cg_client_id: 6     |
        | cwa_chunk[0]:                      |
        |            cw_crc    :  0x32ef89   |
        |            cw_chunk  :  ......     |
        | cwa_chunk[1]:                      |
        |            cw_crc    :  0x56fa89   |
        |            cw_chunk  :  ......     |
        | cwa_chunk[2]:                      |
        |            cw_crc    :  0x7693af   |
        |            cw_chunk  :  ......     |
        +------------------------------------+
          </artwork>
        </figure>

        <t>
          This describes a 3 block write of data from an offset of 1 block in the file.
          As each block shares the cwa_owner, it is only
          presented once. I.e., the data server will be able to construct the
          header for each cwa_chunk from the cwa_payload_id, cwa_owner,
          and cw_crc.
        </t>

        <t>
          Assuming that there were no issues, <xref target='example_CHUNK_WRITE_res_1' />
          illustrates the results. The payload sequence id is implicit in the CHUNK_WRITEargs.
        </t>

        <figure anchor='example_CHUNK_WRITE_res_1'>
          <name>Example of CHUNK_WRITE_res</name>
          <artwork>
        +-------------------------------+
        | CHUNK_WRITEresok              |
        +-------------------------------+
        | cwr_count: 3                  |
        | cwr_committed: FILE_SYNC4     |
        | cwr_writeverf: 0xf1234abc     |
        | cwr_owners[0]:                |
        |        co_chunk_id: 1         |
        |        co_guard:              |
        |            cg_change_id: 3    |
        |            cg_client_id: 6    |
        | cwr_owners[1]:                |
        |        co_chunk_id: 2         |
        |        co_guard:              |
        |            cg_change_id: 3    |
        |            cg_client_id: 6    |
        | cwr_owners[2]:                |
        |        co_chunk_id: 3         |
        |        co_guard:              |
        |            cg_change_id: 3    |
        |            cg_client_id: 6    |
        +-------------------------------+
          </artwork>
        </figure>

        <section anchor='calculating_crc' numbered='true' removeInRFC='false' toc='exclude'>
          <name>Calculating the CRC32</name>
          <figure anchor='crc_before_calc'>
            <name>CRC32 Before Calculation</name>
            <artwork>
        +---+----------------+
        | HEADER             |
        +--------------------+
        | guard:             |
        |   change_id: 7     |
        |   client_id: 6     |
        | payload_id : 0     |
        | crc32   : 0        |
        +--------------------+
        | CHUNK              |
        +--------------------+
        | data:  ....        |
        +--------------------+
             Data Server 1
            </artwork>
          </figure>

          <t>
            Assuming the header and payload as in <xref target='crc_before_calc' />,
            the crc32 needs to be calculated in order to fill in the cw_crc field. In this
            case, the crc32 is calculated over the 3 fields as shown in the
            header and the cw_chunk. In this example, it is calculated
            to be 0x21de8. The resulting CHUNK_WRITE is shown in <xref target='crc_after_calc' />.
          </t>

          <figure anchor='crc_after_calc'>
            <name>CRC32 After Calculation</name>
            <artwork>
        +-----------------------------------+
        | CHUNK_WRITEargs                   |
        +-----------------------------------+
        | cwa_stateid: 0                    |
        | cwa_offset: 1                     |
        | cwa_stable: FILE_SYNC4            |
        | cwa_payload_id: 0                 |
        | cwa_owner:                        |
        |        co_guard:                  |
        |          cg_change_id: 7          |
        |          cg_client_id: 6          |
        | cwa_chunk[0]:                     |
        |        cw_crc    :  0x21de8       |
        |        cw_chunk  :  ......        |
        +-----------------------------------+
            </artwork>
          </figure>
        </section>
      </section>

      <section anchor='sec_decoding_transformation' numbered='true' removeInRFC='false' toc='default'>
        <name>Decoding a Data Block</name>
        <figure anchor='decoding_transformation'>
          <name>Decoding a Data Block</name>
          <artwork>
      Data Server 1          Data Server N          Data Server 6
    +----------------+     +----------------+     +----------------+
    | HEADER         | ... | HEADER         | ... | HEADER         |
    +----------------+     +----------------+     +----------------+
    | guard:         | ... | guard:         | ... | guard:         |
    |   change_id: 3 | ... |   change_id: 3 | ... |   change_id: 3 |
    |   client_id: 6 | ... |   client_id: 6 | ... |   client_id: 6 |
    | payload_id : 0 | ... | payload_id : M | ... | payload_id : 5 |
    | crc32   :      | ... | crc32   :      | ... | crc32   :      |
    +----------------+     +----------------+     +----------------+
    | CHUNK          | ... | CHUNK          | ... | CHUNK          |
    +----------------+     +----------------+     +----------------+
    | data: ....     | ... | data: ....     | ... | data: ....     |
    +---+------------+     +--+-------------+     +-+--------------+
        |                     |                     |
        |                     |                     |
    +---+---------------------+---------------------+-----+
    |            Erasure Decoding (Transform Reverse)     |
    +---------------------+-------------------------------+
                          |
                          |
                  +-------+-----+
                  | data block  |
                  +-------------+
          </artwork>
        </figure>

        <t>
          When reading chunks via a READ operation, the client will decode
          them into data blocks as shown in
          <xref target='decoding_transformation' />.
        </t>

        <t>
          At this time, the
          client could detect issues in the integrity of the data. The handling
          and repair are out of the scope of this document and <bcp14>MUST</bcp14>
          be addressed in the document describing each erasure encoding type.
        </t>
        <section anchor='checking_crc' numbered='true' removeInRFC='false' toc='exclude'>
          <name>Checking the CRC32</name>
          <figure anchor='crc_on_wire'>
            <name>CRC32 on the Wire</name>
            <artwork>
        +------------------------------------+
        | CHUNK_READresok                    |
        +------------------------------------+
        | crr_eof: false                     |
        | crr_chunks[0]:                     |
        |        cr_crc: 0x21de8             |
        |        cr_owner:                   |
        |            co_guard:               |
        |                cg_change_id: 7     |
        |                cg_client_id: 6     |
        |        cr_chunk  :  ......         |
        +------------------------------------+
            </artwork>
          </figure>

          <t>
            Assuming the CHUNK_READ results as in <xref target='crc_on_wire' />,
            the crc32 needs to be checked in order to ensure data integrity. Conceptually,
            a header and payload can be built as shown in <xref target='crc_checking' />.
            The crc32 is calculated over the 3 fields as shown in the
            header and the cr_chunk. In this example, it is calculated
            to be 0x21de8. Thus this payload for the data server has data integrity.
          </t>

          <figure anchor='crc_checking'>
            <name>CRC32 Being Checked</name>
            <artwork>
        +---+----------------+
        | HEADER             |
        +--------------------+
        | guard:             |
        |   change_id: 7     |
        |   client_id: 6     |
        | payload_id  : 0    |
        | crc32    : 0       |
        +--------------------+
        | CHUNK              |
        +--------------------+
        | data:  ....        |
        +--------------------+
             Data Server 1
            </artwork>
          </figure>
        </section>
      </section>

      <section anchor='sec_write_modes' numbered='true' removeInRFC='false' toc='default'>
        <name>Write Modes</name>
        <t>
          There are two basic writing modes for erasure encoding and they depend on
          the metadata server using FFV2_FLAGS_ONLY_ONE_WRITER in the ffl_flags
          in the ffv2_layout4 (see <xref target='code_ffv2_layout4' />) to inform
          the client whether it is the only writer to the file or not. If it
          is the only writer, then CHUNK_WRITE_SWAP can be used to write chunks.
          In this scenario, there is no write contention, but write holes can occur
          as the client overwrites old data. Thus the client does not need guarded
          writes, but it does need the ability to rollback writes. If it is not
          the only writer, then CHUNK_WRITE_SWAP_GUARD <bcp14>MUST</bcp14> be
          used to write chunks. In this scenario, the write holes can also be
          caused by multiple clients writing to the same chunk. Thus the client
          needs guarded writes to prevent over writes and it does need the
          ability to rollback writes.
        </t>
        <t>
          In both modes, clients <bcp14>MUST NOT</bcp14> overwrite payloads
          which already contain inconsistency. This directly follows from
          <xref target='sec_reading' /> and <bcp14>MUST</bcp14> be handled
          as discussed there. Once consistency in the payload has been
          detected, the client can use those chunks as a basis for read/modify/update.
        </t>
        <section>
          <name>Client File for Swapping Chunks</name>
          <t>
            The client does not write chunks directly to the data file, instead
            it first writes them to a per client temporary file and then swaps
            them with the existing chunks in the data file. This swapping allows
            the client to rollback the changes if necessary. The client file
            is created by ROLLBACK_OPEN (see <xref target='ROLLBACK_OPEN' />)
            and is persisted until a ROLLBACK_CLOSE (see <xref target='ROLLBACK_CLOSE' />)
            is sent to the data server. The chunks in the client file <bcp14>MUST</bcp14>
            survive a data server restart. Unlike normal files on a metadata
            server, both data files and client files do not need to be recovered
            by the client in the grace period. After a data server restart, the
            ROLLBACK_LIST (see <xref target='ROLLBACK_LIST' />) can be used to
            recover the client filehandle.
          </t>
          <t>
            <cref anchor='AI41' source='TH'>
              Need to describe the header file and the fact that each client file
              will also need a header file. Do we need a header file if our unit
              of measure is the chunk? Can we just store the header in front of the
              chunk? This will depend on how the XFS swap operates. I.e., is it
              byte ranges or block based?
            </cref>
          </t>
        </section>
        <section>
          <name>Single Writer Mode</name>
          <t>
            If the client detects that the FFV2_FLAGS_ONLY_ONE_WRITER is set, then
            it uses CHUNK_WRITE_SWAP to write chunks first to the client file
            and then swaps those chunks directly to the data file. It then returns
            the chunk owners for the chunks in the data file. The old chunks
            stay in the client file either until overwritten or deleted. The
            issue with keeping them indefinitely comes about during the repair
            process when the client will have to consider all such chunks as
            possibly needing repair.
          </t>
          <t>
            A client will exit the Single Writer Mode when the metadata server
            recalls the layout and the subsequent LAYOUTGET returns the
            FFV2_FLAGS_ONLY_ONE_WRITER as being not set.
          </t>
          <section anchor='sec_sw_repair' numbered='true' removeInRFC='false' toc='default'>
            <name>Repairing Single Writer Payloads</name>
            <t>
              The corruption which occurs is a mixture of new chunks and old chunks
              in the payload. If the client_ids do not match, then the chunks
              with the non-matching id are the old chunks and the ones with
              the same client_id are the new chunks. If the client_ids match,
              then the ones with the smaller change_id are the old chunks,
              and the ones with the larger change_id are the new chunks. Note
              that due to the way change_ids are generated, this comparison
              is only valid for about 49.7 days before the values wrap.
            </t>
            <t>
              The write hole scenarios that can occur with the single writer are:
            </t>
            <ol>
              <li>The client restarts after it has sent M of the N CHUNK_WRITE_SWAP.</li>
              <li>The data server does not receive the CHUNK_WRITE_SWAP.</li>
              <li>
                The data server does not reply to the CHUNK_WRITE_SWAP,
                the client has a FFV2_DS_FLAGS_SPARE, it writes to it,
                and then the original data server responds.
              </li>
              <li>Any combination of the above occuring at the same time.</li>
            </ol>

            <t>
              When the client restarts in the middle of the parallel writes
              to the data servers, the original client might not be the
              one which discovers the write hole. It may be the metadata
              server has tasked a client to scan for write holes after
              it detected that the original client restarted. As such,
              the repair client would be using HEADER_READ to determine
              there was a write hole for this chunk in the payload. The
              repair action here depends on whether there are enough
              new chunks in the payload for the client to decode the
              data block. If there are, then the old chunks can be
              erased. If there are not, then the new chunks are
              rolled back via CHUNK_SWAP.
            </t>
            <t>
              If the data server never receives the write, either the data server was partitioned
              or temporarily down (rebooting or administrative action).
              If a FFV2_DS_FLAGS_SPARE data server was made available
              to the client, then the repair action it to write the chunk
              to a spare. If there are not enough spares available to get consistency,
              then the repair option is to rollback the written chunks via CHUNK_SWAP.
            </t>
            <t>
              If there are a FFV2_DS_FLAGS_ACTIVE and a FFV2_DS_FLAGS_SPARE data
              servers with the same chunk (their payload_ids match), then the repair
              action is to remove the chunk from the FFV2_DS_FLAGS_SPARE
              data server. The reason this <bcp14>MUST</bcp14> be done is that
              an overwrite would only go to the FFV2_DS_FLAGS_ACTIVE data server,
              which might cause a client to get confused when there are two
              different chunks with the same payload_id. The client <bcp14>SHOULD</bcp14>
              be able to figure this out, but a double failure might complicate
              the subsequent repair of the payload.
            </t>
            <t>
              If there are multiple failures of client and data server restarts, the
              repair client will determine if their is consistency in the payload, in
              which case it may decide to make no changes, or if not, then it rolls
              back the chunks via CHUNK_SWAP.
            </t>
            <t>
              <cref anchor='AI45' source='TH'>
                And every subsequent CHUNK_READ will report an error, leading
                to much hand wrangling and little progress. Do we hole punch
                the ones that are not there? Or just rollback in either case
                here?
              </cref>
            </t>
          </section>
        </section>
        <section>
          <name>Mutliple Writer Mode</name>
          <t>
            If the client detects that the FFV2_FLAGS_ONLY_ONE_WRITER is not set, then
            it uses CHUNK_WRITE_SWAP_GUARD to write chunks first to the client file
            and then provisionally swaps those chunks directly to the data file.
            The swap is provisional based on two states:
          </t>

          <dl newline='false' spacing='normal'>
            <dt>matching of the guard values:</dt>
            <dd>
              The CHUNK_WRITE_SWAP_GUARD sends a guard value which is checked
              against the persisted guard values on the chunk. If the guard
              values match, then the swap can proceed to the next check. If
              the values do not match, then the data server <bcp14>MUST</bcp14>
              set the chunk as locked and persist that file attribute.
            </dd>
            <dt>locking state of the chunk:</dt>
            <dd>
              If the chunk is locked, then no other chunk can be swapped in
              on top of it. This prevents racing clients from overwriting
              each other and possibly losing the original chunk contents.
              Once it is locked, either a CHUNK_UNLOCK operation can
              unlock it or a CHUNK_SWAP with the csa_unlock flag set
              unlocks it after swapping the chunks.
            </dd>
          </dl>

          <t>
            CHUNK_WRITE_SWAP_GUARD does not return any error in the case
            that any one of the chunks it writes fails due to either of
            the above criteria. It simply returns
            the chunk owners for the chunks in the data file. The client can
            easily infer that a specfic chunk is locked if the guard did
            not change on that chunk. Once a client determines that a chunk
            is locked, it <bcp14>MUST NOT</bcp14> rewrite to that chunk unless
            it has been informed by the metadata server via CB_CHUNK_REPAIR to repair the chunk
            or by inspection via HEADER_READ it determines that the locking
            state is gone.
          </t>
          <t>
            The old chunks stay in the client file either until overwritten or deleted. The
            issue with keeping them indefinitely comes about during the repair
            process when the client will have to consider all such chunks as
            possibly needing repair.
          </t>
          <t>
            A client will exit the Multiple Writer Mode when the metadata server
            recalls the layout and the subsequent LAYOUTGET returns the
            FFV2_FLAGS_ONLY_ONE_WRITER as being set.
          </t>
        </section>
          <section anchor='sec_mw_repair' numbered='true' removeInRFC='false' toc='default'>
            <name>Repairing Multiple Writer Payloads</name>
            <t>
              When writing chunks, the write either succeeds for the client or fails. If
              all chunk writes in the payload succeed for the client, then it can delete the old chunks
              out of the swap file. If all chunk writes in the payload fail for the
              client, then it if it knows the data block is entirely new data that it
              can abandon the write attempt or retry with an overwrite. If it knows
              that the data block update was a partial update, then it can re-read the
              chunks from the data server and attempt to rewrite the chunks. In any
              of these cases, the failure <bcp14>MUST</bcp14> be reported to the
              metadata server via CHUNK_ERROR. Even though the clients can easily
              determine the winner, there are two scenarios which can lead to deadlock
              in the repair process:
            </t>

            <dl newline='false' spacing='normal'>
              <dt>winning client restarts or permamently goes away:</dt>
              <dd>
                If the clients all determine that the lowest or highest winning
                client_id is the one to repair the chunks, then if it
                restarts or permamently goes away, the other clients will
                be stuck waiting for it to act.
              </dd>
              <dt>winning client is unaware of locked chunks:</dt>
              <dd>
                If the winning client succeed in writing all chunks in the payload,
                and another client failed against each guarded write, then the
                winning client is unaware that the chunks are locked. And while
                the losing clients could detect the consistency and attempt
                to CHUNK_UNLOCK the chunk, that client could restart or go away
                permamently.
              </dd>
            </dl>

            <t>
              Once the metadata server gets the CHUNK_ERROR, it selects a client
              to repair the chunk. It sends a CB_CHUNK_REPAIR, which contains
              both a client_id and a key to use whilst repairing the chunk.
              It will use these values to override what it gets back in the
              LAYOUTGET. The client then uses CHUNK_SWAP(unlock) from the client
              file of the winner to get a consistent payload. If all chunks
              are already consistent, then it CHUNK_UNLOCKs all the chunks
              to release the lock.
            </t>
            <t>
              <cref anchor='AI44' source='TH'>
                client_id and key for each chunk? I.e., it can repair many?
              </cref>
            </t>
            <t>
              If the metadata server detects that the client restarts, then
              it reissues the CB_CHUNK_REPAIR to either that client when it
              comes back online or to any other client.
            </t>
            <t>
              All clients which have detected the inconsistency can determine
              when they can start accessing the chunk via HEADER_READ. Once
              the lock goes away, the clients can CHUNK_READ the chunk to
              decide if they are going to update the chunk.
            </t>
          </section>
      </section>

      <section anchor='sec_reading' numbered='true' removeInRFC='false' toc='default'>
        <name>Reading Chunks</name>
        <t>
          The client reads chunks from the data file via CHUNK_READ. The number of
          chunks in the payload that need to be consistent depend on both the
          Erasure Encoding Type and the level of protection selected. If the
          client has enough consistent chunks in the payload, then it can proceed
          to use them to build a data block. If it does not have enough consistent
          chunks in the payload, then it can either decide to return a LAYOUTERROR
          of NFS4ERR_PAYLOAD_NOT_CONSISTENT to the metadata server or it can retry
          the CHUNK_READ until there are enough consistent chunks in the payload.
        </t>
        <t>
          As another client might be writing to the chunks as they are being read,
          it is entirely possible to read the chunks while they are not consistent.
          As such, it might even be the non-consistent chunks which contain the new
          data and a better action than building the data block is to retry the
          CHUNK_READ to see if new chunks are overwritten.
        </t>
      </section>

    </section>

    <section anchor='errors' numbered='true' removeInRFC='false' toc='default'>
      <name>New NFSv4.2 Error Values</name>
      <figure anchor='code_errors'>
        <name>Errors XDR</name>
        <sourcecode type='xdr'>
///
/// /* Erasure Encoding errors start here */
///
/// NFS4ERR_XATTR2BIG      = 10096,/* xattr value is too big  */
/// NFS4ERR_ENCODING_NOT_SUPPORTED
///    = 10097,/* Encoding Type unsupported  */
/// NFS4ERR_PAYLOAD_NOT_CONSISTENT= 10098/* payload inconsitent  */
///
        </sourcecode>
      </figure>

      <t>
        The new error codes are shown in <xref target='code_errors' />.
      </t>

      <section anchor='errors_defs' numbered='true' removeInRFC='false' toc='default'>
        <name>Error Definitions</name>

        <table anchor='tbl_error_defs'>
          <name>Protocol Error Definitions</name>
          <thead>
            <tr>
              <th>Error</th>
              <th>Number</th>
              <th>Description</th>
            </tr>
          </thead>
          <tbody>
            <tr> <td>NFS4ERR_ENCODING_NOT_SUPPORTED</td> <td>10097</td> <td><xref target='NFS4ERR_ENCODING_NOT_SUPPORTED' /></td> </tr>
            <tr> <td>NFS4ERR_PAYLOAD_NOT_CONSISTENT</td> <td>10098</td> <td><xref target='NFS4ERR_PAYLOAD_NOT_CONSISTENT' /></td> </tr>
          </tbody>
        </table>

        <section anchor='NFS4ERR_ENCODING_NOT_SUPPORTED' numbered='true' removeInRFC='false' toc='exclude'>
          <name>NFS4ERR_ENCODING_NOT_SUPPORTED (Error Code 10097)</name>
          <t>
            The client requested a ffv2_encoding_type4 which the metadata server does not support. I.e.,
            if the client sends a layout_hint requesting an erasure encoding type that the
            metadata server does not support, this error code can be returned. The client
            might have to send the layout_hint several times to determine the overlapping
            set of supported erasure encoding types.
          </t>
        </section>
        <section anchor='NFS4ERR_PAYLOAD_NOT_CONSISTENT' numbered='true' removeInRFC='false' toc='exclude'>
          <name>NFS4ERR_PAYLOAD_NOT_CONSISTENT (Error Code 10098)</name>
          <t>
            The client encountered a payload in which the blocks were inconsistent and
            stays inconsistent. As the client can not tell if another client is
            actively writing, it informs the metadata server of this error via
            LAYOUTERROR4.  The metadata server can then arrange for
            repair of the file.
          </t>
        </section>
      </section>

      <section anchor='ops_to_errors' numbered='true' removeInRFC='false' toc='default'>
        <name>Operations and Their Valid Errors</name>

        <t>
          The operations and their valid errors are presented in <xref target='tbl_ops_to_errors' />.
          All error codes not defined in this document are defined in Section 15
          of <xref target='RFC8881' /> and Section 11 of <xref target='RFC7862' />.
        </t>

        <table anchor='tbl_ops_to_errors'>
          <name>Operations and Their Valid Errors</name>
          <thead>
            <tr>
              <th>Operation</th>
              <th>Errors</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>ROLLBACK_OPEN</td>
              <td>
                NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,
                NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION, NFS4ERR_DELAY,
                NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT, NFS4ERR_EXPIRED,
                NFS4ERR_FBIG, NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,
                NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,
                NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,
                NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,
                NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_PNFS_IO_HOLE,
                NFS4ERR_PNFS_NO_LAYOUT, NFS4ERR_REP_TOO_BIG,
                NFS4ERR_REP_TOO_BIG_TO_CACHE, NFS4ERR_REQ_TOO_BIG,
                NFS4ERR_RESERVATION_CONFLICT, NFS4ERR_RETRY_UNCACHED_REP,
                NFS4ERR_ROFS, NFS4ERR_SERVERFAULT, NFS4ERR_STALE,
                NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE
              </td>
            </tr>
            <tr>
              <td>ROLLBACK_LIST</td>
              <td>
                NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,
                NFS4ERR_DEADSESSION, NFS4ERR_DELAY, NFS4ERR_DELEG_REVOKED,
                NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,
                NFS4ERR_ISDIR, NFS4ERR_LOCKED, NFS4ERR_MOVED, NFS4ERR_NOENT,
                NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP, NFS4ERR_OPENMODE,
                NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_PNFS_IO_HOLE,
                NFS4ERR_PNFS_NO_LAYOUT, NFS4ERR_REP_TOO_BIG,
                NFS4ERR_REP_TOO_BIG_TO_CACHE, NFS4ERR_REQ_TOO_BIG,
                NFS4ERR_RESERVATION_CONFLICT, NFS4ERR_RETRY_UNCACHED_REP,
                NFS4ERR_SERVERFAULT, NFS4ERR_STALE, NFS4ERR_SYMLINK,
                NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE
              </td>
            </tr>
            <tr>
              <td>ROLLBACK_OPEN_RECOVER</td>
              <td>
                NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,
                NFS4ERR_DELAY, NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,
                NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,
                NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP,
                NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_PERM,
                NFS4ERR_REP_TOO_BIG, NFS4ERR_REP_TOO_BIG_TO_CACHE,
                NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP,
                NFS4ERR_STALE, NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,
                NFS4ERR_WRONG_CRED, NFS4ERR_WRONG_TYPE
              </td>
            </tr>
            <tr>
              <td>ROLLBACK_CLOSE</td>
              <td>
                NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,
                NFS4ERR_DELAY, NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,
                NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,
                NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP,
                NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_PERM,
                NFS4ERR_REP_TOO_BIG, NFS4ERR_REP_TOO_BIG_TO_CACHE,
                NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP,
                NFS4ERR_STALE, NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,
                NFS4ERR_WRONG_CRED, NFS4ERR_WRONG_TYPE
              </td>
            </tr>
          </tbody>
        </table>
      </section>

      <section anchor='cb_ops_to_errors' numbered='true' removeInRFC='false' toc='default'>
        <name>Callback Operations and Their Valid Errors</name>

        <t>
          The callback operations and their valid errors are presented in <xref target='tbl_cb_ops_to_errors' />.
          All error codes not defined in this document are defined in Section 15
          of <xref target='RFC8881' /> and Section 11 of <xref target='RFC7862' />.
        </t>

        <table anchor='tbl_cb_ops_to_errors'>
          <name>Callback Operations and Their Valid Errors</name>
          <thead>
            <tr>
              <th>Callback Operation</th>
              <th>Errors</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>CB_CHUNK_REPAIR</td>
              <td>
                NFS4ERR_BADXDR,
                NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION, NFS4ERR_DELAY,
                NFS4ERR_ENCODING_NOT_SUPPORTED,
                NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,
                NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,
                NFS4ERR_SERVERFAULT, NFS4ERR_STALE,
              </td>
            </tr>
          </tbody>
        </table>
      </section>

      <section anchor='errors_to_ops' numbered='true' removeInRFC='false' toc='default'>
        <name>Errors and the Operations That Use Them</name>

        <t>
          The operations and their valid errors are presented in <xref target='tbl_error_to_ops' />.
          All operations not defined in this document are defined in Section 18
          of <xref target='RFC8881' /> and Section 15 of <xref target='RFC7862' />.
        </t>

        <table anchor='tbl_error_to_ops'>
          <name>Errors and the Operations That Use Them</name>
          <thead>
            <tr>
              <th>Error</th>
              <th>Operations</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>NFS4ERR_ENCODING_NOT_SUPPORTED</td>
              <td>
                CB_CHUNK_REPAIR, LAYOUTGET
              </td>
            </tr>
            <tr>
              <td>NFS4ERR_RESERVATION_CONFLICT</td>
              <td>
                ROLLBACK_OPEN
              </td>
            </tr>
            <tr>
              <td>NFS4ERR_RESERVATION_FILE</td>
              <td>
                CLOSE, LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP, OPEN, OPENATTR, READLINK,
                REMOVE, RENAME, SETATTR, VERIFY
              </td>
            </tr>
            <tr>
              <td>NFS4ERR_RESERVATION_HELD</td>
              <td>
                COMMIT, READ, WRITE
              </td>
            </tr>
            <tr>
              <td>NFS4ERR_RESERVATION_OUT_OF_RANGE</td>
              <td>
                COMMIT, READ, WRITE
              </td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>

    <section anchor='EXCHGID4_FLAG_USE_ERASURE_DS' numbered='true' removeInRFC='false' toc='default'>
      <name>EXCHGID4_FLAG_USE_PNFS_DS</name>
      <figure anchor='code_EXCHGID4_FLAG_USE_ERASURE_DS'>
        <name>XDR for EXCHGID4_FLAG_USE_PNFS_DS</name>
        <sourcecode type='xdr'>
/// const EXCHGID4_FLAG_USE_ERASURE_DS      = 0x00100000;
        </sourcecode>
      </figure>

      <t>
        When a data server connects to a metadata server it
        can via EXCHANGE_ID (see Section 18.35 of <xref target='RFC8881' />) state its pNFS role.
        The data server can use EXCHGID4_FLAG_USE_ERASURE_DS
        (see <xref target='code_EXCHGID4_FLAG_USE_ERASURE_DS' />)
        to indicate that it supports the new NFSv4.2 operations
        introduced in this document.  Section 13.1 <xref target='RFC8881' /> describes the
        interaction of the various pNFS roles masked by EXCHGID4_FLAG_MASK_PNFS.
        However, that does not mask out EXCHGID4_FLAG_USE_ERASURE_DS.
        I.e., EXCHGID4_FLAG_USE_ERASURE_DS can be used in combination
        with all of the pNFS flags.
      </t>
      <t>
        If the data server sets EXCHGID4_FLAG_USE_ERASURE_DS during the
        EXCHANGE_ID operation, then it <bcp14>MUST</bcp14> support:
        ROLLBACK_OPEN, ROLLBACK_LIST, ROLLBACK_OPEN_RECOVER, ROLLBACK_CLOSE,
        and ROLLBACK_OPEN_SWAP. Further, note that this support is
        orthogonal to the Erasure Encoding Type selected. The
        data server is unaware of which type is driving the I/O.
      </t>
    </section>

    <section anchor='attrs' numbered='true' removeInRFC='false' toc='default'>
      <name>New NFSv4.2 Attributes</name>
      <section anchor='fattr4_encoding_block_size' numbered='true' removeInRFC='false' toc='default'>
        <name>Attribute 88: fattr4_encoding_block_size</name>
        <figure anchor='code_fattr4_encoding_block_size'>
          <name>XDR for fattr4_encoding_block_size</name>
          <sourcecode type='xdr'>
/// typedef size_t                    fattr4_encoding_block_size;
///
/// const FATTR4_ENCODING_BLOCK_SIZE  = 88;
///
          </sourcecode>
        </figure>
        <t>
          The new attribute fattr4_encoding_block_size (see
          <xref target='code_fattr4_encoding_block_size'/>) is
          an <bcp14>OPTIONAL</bcp14> to NFSv4.2 attribute which
          <bcp14>MUST</bcp14> be supported if the metadata server supports
          the Flexible File Version 2 Layout Type. By querying it, the
          client can determine the data block size it is to use
          when encoding the data blocks to chunks.
        </t>
      </section>
    </section>

    <section anchor='common_data_structure' numbered='true' removeInRFC='false' toc='default'>
      <name>New NFSv4.2 Common Data Structures</name>
      <section anchor='chunk_guard4' numbered='true' removeInRFC='false' toc='default'>
        <name>chunk_guard4</name>
        <figure anchor='code_chunk_guard4'>
          <name>XDR for chunk_guard4</name>
          <sourcecode type='xdr'>
/// struct chunk_guard4 {
///     uint32_t   cg_change_id;
///     uint32_t   cg_client_id;
/// };
          </sourcecode>
        </figure>
        <t>
          The chunk_guard4 (see <xref target='code_chunk_guard4' />) is effectively a 64 bit value, with
          the upper 32 bits, cg_change_id,  being the current time in ms and the lower 32
          bits, cg_client_id, being an unique id established when the client did the
          EXCHANGE_ID operation (see Section 18.35 of <xref target='RFC8881' />)
          with the metadata server. The lower 32 bits are set passed
          back in the LAYOUTGET operation (see Section 18.43 of <xref target='RFC8881' />)
          as the fml_client_id (see <xref target='ffv2_mirror4' />).
        </t>
        <t>
          When comparing two chunk_guard4 data stuctures src and dst, using the standard
          comparision results of -1 for src &amp; dst, 0 for src = dst, and +1 for
          src &gt; dst, the algorithm is shown in <xref target='code_chunk_guard4_cmp' />.
        </t>
        <figure anchor='code_chunk_guard4_cmp'>
          <name>Comparing two chunk_guard4</name>
          <sourcecode type='c'>
/// int compare_chunk_guard(chunk_guard4 src, chunk_guard4 dst)
/// {
///     if (src.cg_change_id &amp; dst.cg_change_id) {
///         return -1;
///     } else if (src.cg_change_id &gt; dst.cg_change_id) {
///         return 1;
///     } else if (src.cg_client_id &amp; dst.cg_client_id ) {
///         return -1;
///     } else if (src.cg_client_id &gt; dst.cg_client_id) {
///         return 1;
///     }
///     return 0;
/// };
          </sourcecode>
        </figure>
        <t>
          <cref anchor='AI40' source='TH'>
            Do we need the comparison algorithm?
          </cref>
        </t>
      </section>

      <section anchor='chunk_owner4' numbered='true' removeInRFC='false' toc='default'>
        <name>chunk_owner4</name>
        <figure anchor='code_chunk_owner4'>
          <name>XDR for code_chunk_owner4</name>
          <sourcecode type='xdr'>
/// struct chunk_owner4 {
///     chunk_guard4   co_guard;
///     uint32_t       co_id;
/// };
          </sourcecode>
        </figure>
        <t>
          The chunk_owner4 (see <xref target='code_chunk_owner4' />)
          is used to determine when and by whom a block was written.
          The co_id is used to identify the block and <bcp14>MUST</bcp14>
          be the index of the chunk within the file. I.e., it is the
          offset of the start of the chunk divided by the chunk length.
          The co_guard is a chunk_guard4 (see <xref target='chunk_guard4' />
          used to identify a given transaction.
        </t>
        <t>
          The co_guard is like the change attribute
          (see Section 5.8.1.4 of <xref target='RFC8881' format='default'
          sectionFormat='of' />) in that each chunk write by a given
          client has to have an unique co_guard. I.e., it can
          be determined which transaction across all data files that
          a chunk corresponds.
        </t>
      </section>
    </section>

    <section anchor='ops' numbered='true' removeInRFC='false' toc='default'>
      <name>New NFSv4.2 Operations</name>

      <figure anchor='code_ops'>
        <name>Operations XDR</name>
        <sourcecode type='xdr'>
///
/// /* New operations for Erasure Encoding start here */
///
///  OP_CHUNK_COMMIT        = 77,
///  OP_CHUNK_ERROR         = 78,
///  OP_CHUNK_LOCK          = 79,
///  OP_CHUNK_READ          = 80,
///  OP_CHUNK_SWAP          = 81,
///  OP_CHUNK_UNLOCK        = 82,
///  OP_CHUNK_WRITE         = 83,
///  OP_CHUNK_WRITE_SWAP    = 84,
///  OP_CHUNK_WRITE_SWAP_GUARD = 85,
///  OP_GUARD_SWAP          = 86,
///  OP_HEADER_READ         = 87,
///  OP_ROLLBACK_CLOSE      = 88,
///  OP_ROLLBACK_LIST       = 89,
///  OP_ROLLBACK_OPEN       = 90,
///  OP_SWAP                = 91,
///
        </sourcecode>
      </figure>


      <table anchor='tbl_op_defs'>
        <name>Protocol Operation Definitions</name>
        <thead>
          <tr>
            <th>Operation</th>
            <th>Number</th>
            <th>Target Server</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr> <td>CHUNK_COMMIT</td> <td>77</td> <td>DS</td> <td><xref target='CHUNK_COMMIT' /></td> </tr>
          <tr> <td>CHUNK_ERROR</td> <td>78</td> <td>MDS</td> <td><xref target='CHUNK_READ' /></td> </tr>
          <tr> <td>CHUNK_LOCK</td> <td>79</td> <td>DS</td> <td><xref target='CHUNK_READ' /></td> </tr>
          <tr> <td>CHUNK_READ</td> <td>80</td> <td>DS</td> <td><xref target='CHUNK_READ' /></td> </tr>
          <tr> <td>CHUNK_SWAP</td> <td>81</td> <td>DS</td> <td><xref target='CHUNK_READ' /></td> </tr>
          <tr> <td>CHUNK_UNLOCK</td> <td>82</td> <td>DS</td> <td><xref target='CHUNK_READ' /></td> </tr>
          <tr> <td>CHUNK_WRITE</td> <td>83</td> <td>DS</td> <td><xref target='CHUNK_WRITE' /></td> </tr>
          <tr> <td>CHUNK_WRITE_SWAP</td> <td>84</td> <td>DS</td> <td><xref target='CHUNK_WRITE' /></td> </tr>
          <tr> <td>CHUNK_WRITE_SWAP_GUARD</td> <td>DS</td> <td>85</td> <td><xref target='CHUNK_WRITE' /></td> </tr>
          <tr> <td>GUARD_SWAP</td> <td>86</td> <td>DS</td> <td><xref target='CHUNK_WRITE' /></td> </tr>
          <tr> <td>HEADER_READ</td> <td>87</td> <td>DS</td> <td><xref target='HEADER_READ' /></td> </tr>
          <tr> <td>ROLLBACK_CLOSE</td> <td>88</td> <td>DS</td> <td><xref target='ROLLBACK_LIST' /></td> </tr>
          <tr> <td>ROLLBACK_LIST</td> <td>89</td> <td>DS</td> <td><xref target='ROLLBACK_LIST' /></td> </tr>
          <tr> <td>ROLLBACK_OPEN</td> <td>90</td> <td>DS</td> <td><xref target='ROLLBACK_LIST' /></td> </tr>
          <tr> <td>SWAP</td> <td>91</td> <td>non-pNFS, MDS, DS</td> <td><xref target='ROLLBACK_LIST' /></td> </tr>
        </tbody>
      </table>

      <section anchor='CHUNK_COMMIT' numbered='true' removeInRFC='false' toc='default'>
        <name>Operation 77: CHUNK_COMMIT - Activate Cached Chunk Data</name>
        <section anchor='CHUNK_COMMIT4args' numbered='true' removeInRFC='false' toc='exclude'>
          <name>ARGUMENTS</name>
          <figure anchor='code_CHUNK_COMMIT4args'>
            <name>XDR for CHUNK_COMMIT4args</name>
            <sourcecode type='xdr'>
/// struct CHUNK_COMMIT4args {
///     /* CURRENT_FH: file */
///     offset4         cca_offset;
///     count4          cca_count;
///     chunk_owner4    cca_chunks&lt;&gt;;
/// };
            </sourcecode>
          </figure>
        </section>

        <section anchor='CHUNK_COMMIT4res' numbered='true' removeInRFC='false' toc='exclude'>
          <name>RESULTS</name>
          <figure anchor='code_CHUNK_COMMIT4resok'>
            <name>XDR for CHUNK_COMMIT4resok</name>
            <sourcecode type='xdr'>
/// struct CHUNK_COMMIT4resok {
///     verifier4       ccr_writeverf;
/// };
            </sourcecode>
          </figure>

          <figure anchor='code_CHUNK_COMMIT4res'>
            <name>XDR for CHUNK_COMMIT4res</name>
            <sourcecode type='xdr'>
/// union CHUNK_COMMIT4res switch (nfsstat4 ccr_status) {
///     case NFS4_OK:
///         CHUNK_COMMIT4resok   ccr_resok4;
///     default:
///         void;
/// };
            </sourcecode>
          </figure>
        </section>

        <section anchor='CHUNK_COMMIT_desc' numbered='true' removeInRFC='false' toc='exclude'>
          <name>DESCRIPTION</name>
          <t>
            CHUNK_COMMIT is COMMIT (see Section 18.3 of <xref target='RFC8881'
            format='default' sectionFormat='of' />) with additional semantics
            over the chunk_owner activating the blocks. As such, all of
            the normal semantics of COMMIT directly apply.
          </t>
          <t>
            The main difference between the two operations is that CHUNK_COMMIT
            works on blocks and not a raw data stream. As such cca_offset
            is the starting block offset in the file and not the byte
            offset in the file. Some erasure encoding types can have
            different block sizes depending on the
            block type. Further, cca_count is a count of blocks to activate
            and not bytes to activate.
          </t>
          <t>
            Further, while it may appear that the combination of cca_offset
            and cca_count are redundant to cca_chunks, the purpose of
            cca_chunks is to allow the data server to differentiate between
            potentially multiple pending blocks.
          </t>
        </section>
      </section>

      <section anchor='CHUNK_READ' numbered='true' removeInRFC='false' toc='default'>
        <name>Operation 78: CHUNK_READ - Read Chunks from File</name>
        <section anchor='CHUNK_READ4args' numbered='true' removeInRFC='false' toc='exclude'>
          <name>ARGUMENTS</name>
          <figure anchor='code_CHUNK_READ4args'>
            <sourcecode type='xdr'>
/// struct CHUNK_READ4args {
///     /* CURRENT_FH: file */
///     stateid4    cra_stateid;
///     offset4     cra_offset;
///     count4      cra_count;
/// };
            </sourcecode>
          </figure>
        </section>

        <section anchor='CHUNK_READ4res' numbered='true' removeInRFC='false' toc='exclude'>
          <name>RESULTS</name>

          <figure anchor='code_read_chunk4'>
            <sourcecode type='xdr'>
/// struct read_chunk4 {
///     uint32_t        cr_crc;
///     uint32_t        cr_effective_len;
///     chunk_owner4    cr_owner;
///     uint32_t        cr_payload_id;
///     opaque          cr_chunk&lt;&gt;;
/// };
            </sourcecode>
          </figure>

          <figure anchor='code_CHUNK_READ4resok'>
            <sourcecode type='xdr'>
/// struct CHUNK_READ4resok {
///     bool        crr_eof;
///     read_chunk4 crr_chunks&lt;&gt;;
/// };
            </sourcecode>
          </figure>

          <figure anchor='code_CHUNK_READ4res'>
            <sourcecode type='xdr'>
/// union CHUNK_READ4res switch (nfsstat4 crr_status) {
///     case NFS4_OK:
///          CHUNK_READ4resok     crr_resok4;
///     default:
///          void;
/// };
            </sourcecode>
          </figure>
        </section>

        <section anchor='CHUNK_READ_desc' numbered='true' removeInRFC='false' toc='exclude'>
          <name>DESCRIPTION</name>
          <t>
            CHUNK_READ is READ (see Section 18.22 of <xref target='RFC8881'
            format='default' sectionFormat='of' />) with additional semantics
            over the chunk_owner. As such, all of the normal semantics of READ directly apply.
          </t>
          <t>
            The main difference between the two operations is that CHUNK_READ
            works on blocks and not a raw data stream. As such cra_offset
            is the starting block offset in the file and not the byte
            offset in the file. Some erasure encoding types can have
            different block sizes depending on the
            block type. Further, cra_count is a count of blocks to read
            and not bytes to read.
          </t>
          <t>
            When reading a set of blocks across the data servers, it can be
            the case that some data servers do not have any data at that
            location. In that case, the server either returns crr_eof
            if the cra_offset exceeds the number of blocks that
            the data server is aware or it returns an empty block
            for that block.
          </t>

          <t>
            For example, in <xref target='example_CHUNK_READ4args_1' />, the
            client asks for 4 blocks starting with the 3rd block in the file.
            The second data server responds as in <xref target='example_CHUNK_READ4res_1' />.
            The client would read this as there is valid data for blocks 2 and
            4, there is a hole at block 3, and there is no data for block 5.
            The data server <bcp14>MUST</bcp14> calculate a valid
            cr_crc for block 3 based on the generated fields.
          </t>

          <figure anchor='example_CHUNK_READ4args_1'>
            <artwork>
                Data Server 2
        +--------------------------------+
        | CHUNK_READ4args                |
        +--------------------------------+
        | cra_stateid: 0                 |
        | cra_offset: 2                  |
        | cra_count: 4                   |
        +----------+---------------------+
            </artwork>
          </figure>

        <figure anchor='example_CHUNK_READ4res_1'>
          <artwork>
                Data Server 2
        +--------------------------------+
        | CHUNK_READ4resok               |
        +--------------------------------+
        | crr_eof: true                  |
        | crr_chunks[0]:                 |
        |     cr_crc: 0x3faddace         |
        |     cr_owner:                  |
        |         co_chunk_id: 2         |
        |         co_guard:              |
        |             cg_change_id: 3    |
        |             cg_client_id: 6    |
        |     cr_payload_id: 1           |
        |     cr_chunk: ....             |
        | crr_chunks[0]:                 |
        |     cr_crc: 0xdeade4e5         |
        |     cr_owner:                  |
        |         co_chunk_id: 3         |
        |         co_guard:              |
        |             cg_change_id: 0    |
        |             cg_client_id: 0    |
        |     cr_payload_id: 1           |
        |     cr_chunk: 0000...00000     |
        | crr_chunks[0]:                 |
        |     cr_crc: 0x7778abcd         |
        |     cr_owner:                  |
        |         co_chunk_id: 4         |
        |         co_guard:              |
        |             cg_change_id: 3    |
        |             cg_client_id: 6    |
        |     cr_payload_id: 1           |
        |     cr_chunk: ....             |
        +--------------------------------+
          </artwork>
        </figure>

        </section>
      </section>

      <section anchor='HEADER_READ' numbered='true' removeInRFC='false' toc='default'>
        <name>Operation 79: HEADER_READ - Read Chunk Header from File</name>
        <section anchor='HEADER_READ4args' numbered='true' removeInRFC='false' toc='exclude'>
          <name>ARGUMENTS</name>
          <figure anchor='code_HEADER_READ4args'>
            <sourcecode type='xdr'>
/// struct HEADER_READ4args {
///     /* CURRENT_FH: file */
///     stateid4    hra_stateid;
///     offset4     hra_offset;
///     count4      hra_count;
/// };
            </sourcecode>
          </figure>
        </section>

        <section anchor='HEADER_READ4res' numbered='true' removeInRFC='false' toc='exclude'>
          <name>RESULTS</name>
          <figure anchor='code_HEADER_READ4resok'>
            <sourcecode type='xdr'>
/// struct HEADER_READ4resok {
///     bool            hrr_eof;
///     chunk_owner4    hrr_chunks&lt;&gt;;
/// };
            </sourcecode>
          </figure>

          <figure anchor='code_HEADER_READ4res'>
            <sourcecode type='xdr'>
/// union HEADER_READ4res switch (nfsstat4 hrr_status) {
///     case NFS4_OK:
///         HEADER_READ4resok     hrr_resok4;
///     default:
///         void;
/// };
            </sourcecode>
          </figure>
        </section>

        <section anchor='HEADER_READ4_desc' numbered='true' removeInRFC='false' toc='exclude'>
          <name>DESCRIPTION</name>
          <t>
            HEADER_READ differs from CHUNK_READ in that it only reads
            chunk headers in the desired data range.
          </t>
        </section>
      </section>

      <section anchor='ROLLBACK_CHUNK' numbered='true' removeInRFC='false' toc='default'>
        <name>Operation 80: ROLLBACK_CHUNK - Rollback Cached Chunk Data</name>
        <section anchor='ROLLBACK_CHUNK4args' numbered='true' removeInRFC='false' toc='exclude'>
          <name>ARGUMENTS</name>
          <figure anchor='code_ROLLBACK_CHUNK4args'>
            <sourcecode type='xdr'>
/// struct ROLLBACK_CHUNK4args {
///     /* CURRENT_FH: file */
///     offset4         cra_offset;
///     count4          cra_count;
///     chunk_owner4    cra_chunks&lt;&gt;;
/// };
            </sourcecode>
          </figure>
        </section>

        <section anchor='ROLLBACK_CHUNK4res' numbered='true' removeInRFC='false' toc='exclude'>
          <name>RESULTS</name>
          <figure anchor='code_ROLLBACK_CHUNK4resok'>
            <sourcecode type='xdr'>
/// struct ROLLBACK_CHUNK4resok {
///     verifier4       crr_writeverf;
/// };
            </sourcecode>
          </figure>

          <figure anchor='code_ROLLBACK_CHUNK4res'>
            <sourcecode type='xdr'>
/// union ROLLBACK_CHUNK4res switch (nfsstat4 crr_status) {
///     case NFS4_OK:
///         ROLLBACK_CHUNK4resok   crr_resok4;
///     default:
///         void;
/// };
            </sourcecode>
          </figure>
        </section>

        <section anchor='ROLLBACK_CHUNK_desc' numbered='true' removeInRFC='false' toc='exclude'>
          <name>DESCRIPTION</name>
          <t>
            ROLLBACK_CHUNK is a new form like COMMIT (see Section 18.3 of <xref target='RFC8881'
            format='default' sectionFormat='of' />) with additional semantics
            over the chunk_owner the rolling back the writing of blocks. As such, all of
            the normal semantics of COMMIT directly apply.
          </t>

          <t>
            The main difference between the two operations is that ROLLBACK_CHUNK
            works on blocks and not a raw data stream. As such cra_offset
            is the starting block offset in the file and not the byte
            offset in the file. Some erasure encoding types can have
            different block sizes depending on the
            block type. Further, cra_count is a count of blocks to rollback
            and not bytes to rollback.
          </t>
          <t>
            Further, while it may appear that the combination of cra_offset
            and cra_count are redundant to cra_chunks, the purpose of
            cra_chunks is to allow the data server to differentiate between
            potentially multiple pending blocks.
          </t>

          <t>
            ROLLBACK_CHUNK deletes prior CHUNK_WRITE transactions. In case of write
            holes, it allows the client to undo transactions to repair the file.
          </t>
        </section>
      </section>

      <section anchor='CHUNK_WRITE' numbered='true' removeInRFC='false' toc='default'>
        <name>Operation 81: CHUNK_WRITE - Write Chunks to File</name>
        <section anchor='CHUNK_WRITE4args' numbered='true' removeInRFC='false' toc='exclude'>
          <name>ARGUMENTS</name>

          <figure anchor='code_cw_args_flags'>
            <sourcecode type='xdr'>
/// const CHUNK_WRITE_FLAGS_UPDATE_HEADER_ONLY   = 0x00000001;
/// const CHUNK_WRITE_FLAGS_ACTIVATE_IF_EMPTY    = 0x00000002;
            </sourcecode>
          </figure>

          <figure anchor='code_write_chunk4'>
            <sourcecode type='xdr'>
/// struct write_chunk4 {
///     uint32_t        cw_crc;
///     uint32_t        cw_flags;
///     opaque          cw_chunk&lt;&gt;;
/// };
            </sourcecode>
          </figure>

          <figure anchor='code_write_chunk_guard4'>
            <sourcecode type='xdr'>
/// union write_chunk_guard4 (bool cwg_check) {
///     case TRUE:
///         chunk_guard4   cwg_guard;
///     case FALSE:
///         void;
/// };
            </sourcecode>
          </figure>

          <figure anchor='code_CHUNK_WRITE4args'>
            <sourcecode type='xdr'>
/// struct CHUNK_WRITE4args {
///     /* CURRENT_FH: file */
///     stateid4           cwa_stateid;
///     offset4            cwa_offset;
///     stable_how4        cwa_stable;
///     chunk_owner4       cwa_owner;
///     uint32_t           cwa_payload_id;
///     write_chunk_guard4 cwa_guard;
///     write_chunk4       cwa_data&lt;&gt;;
/// };
            </sourcecode>
          </figure>
        </section>

        <section anchor='CHUNK_WRITE4res' numbered='true' removeInRFC='false' toc='exclude'>
          <name>RESULTS</name>

          <figure anchor='code_CHUNK_WRITE4resok'>
            <sourcecode type='xdr'>
/// struct CHUNK_WRITE4resok {
///     count4          cwr_count;
///     stable_how4     cwr_committed;
///     verifier4       cwr_writeverf;
///     chunk_owner4    cwr_owners&lt;&gt;;
/// };
            </sourcecode>
          </figure>

          <figure anchor='code_CHUNK_WRITE4res'>
            <sourcecode type='xdr'>
/// union CHUNK_WRITE4res switch (nfsstat4 cwr_status) {
///     case NFS4_OK:
///         CHUNK_WRITE4resok    cwr_resok4;
///     default:
///         void;
/// };
            </sourcecode>
          </figure>
        </section>

        <section anchor='CHUNK_WRITE_desc' numbered='true' removeInRFC='false' toc='exclude'>
          <name>DESCRIPTION</name>
          <t>
            CHUNK_WRITE is WRITE (see Section 18.32 of <xref target='RFC8881'
            format='default' sectionFormat='of' />) with additional semantics
            over the chunk_owner and the activation of blocks. As such, all of
            the normal semantics of WRITE directly apply.
          </t>
          <t>
            The main difference between the two operations is that CHUNK_WRITE
            works on blocks and not a raw data stream. As such cwa_offset
            is the starting block offset in the file and not the byte
            offset in the file. Some erasure encoding types can have
            different block sizes depending on the
            block type. Further, cwr_count is a count of written blocks
            and not written bytes.
          </t>
          <t>
            If cwa_stable is FILE_SYNC4, the
            data server <bcp14>MUST</bcp14> commit the written header and block data plus all file system metadata to
            stable storage before returning results.  This corresponds to the
            NFSv2 protocol semantics.  Any other behavior constitutes a protocol
            violation.  If cwa_stable is DATA_SYNC4, then the data server <bcp14>MUST</bcp14> commit all
            of the header and block data  to stable storage and enough of the metadata to retrieve
            the data before returning.  The data server implementer is free to
            implement DATA_SYNC4 in the same fashion as FILE_SYNC4, but with a
            possible performance drop.  If cwa_stable is UNSTABLE4, the data server is
            free to commit any part of the header and  block data and the metadata to stable
            storage, including all or none, before returning a reply to the
            client.  There is no guarantee whether or when any uncommitted data
            will subsequently be committed to stable storage.  The only
            guarantees made by the data server are that it will not destroy any data
            without changing the value of writeverf and that it will not commit
            the data and metadata at a level less than that requested by the
            client.
          </t>
          <t>
            The activation of header and block data interacts with the co_activated
            for each of the written blocks. If the data is not committed
            to stable storage then the co_activated field <bcp14>MUST NOT</bcp14>
            be set to true. Once the data is committed to stable storage, then
            the data server can set the block's co_activated if one of these
            conditions apply:
          </t>
          <ul>
            <li>
              it is the first write to that block and the CHUNK_WRITE_FLAGS_ACTIVATE_IF_EMPTY flag is set
            </li>
            <li>
              the CHUNK_COMMIT is issued later for that block.
            </li>
          </ul>
          <t>
            There are subtle interactions with write holes caused by racing
            clients. One client could win the race in each case, but because
            it used a cwa_stable of UNSTABLE4, the subsequent writes from
            the second client with a cwa_stable of FILE_SYNC4 can be awarded
            the co_activated being set to true for each of the blocks in
            the payload.
          </t>
          <t>
            Finally, the interaction of cwa_stable can cause a client to
            mistakenly believe that by the time it gets the response of
            co_activated of false, that the blocks are not activated. A
            subsequent CHUNK_READ or HEADER_READ might show that
            the co_activated is true without any interaction by the client
            via CHUNK_COMMIT.
          </t>

          <section anchor='guarded_write' numbered='true' removeInRFC='false' toc='exclude'>
            <name>Guarding the Write</name>
            <t>
              A guarded CHUNK_WRITE is when the writing of a block
              <bcp14>MUST</bcp14> fail if cwa_guard.cwg_check is set
              and the target chunk does not have both the same change_id
              cwa_guard.as the cwg_guard.cg_change_id and the same cwa_guard.cg_change_id as the
              cwa_guard.cwg_guard.cg_change_id. This is useful in read-update-write
              scenarios. The client reads a block, updates it, and
              is prepared to write it back. It guards the write such
              that if another writer has modified the block, the
              data server will reject the modification.
            </t>
            <t>
              As the chunk_guard4 (see <xref target='code_chunk_guard4' />
              does not have a chunk_id and the CHUNK_WRITE applies
              to all blocks in the range of cwa_offset to the length
              of cwa_data, then each of the target blocks
              <bcp14>MUST</bcp14> have the same cg_change_id and
              cg_client_id. The client <bcp14>SHOULD</bcp14> present
              the smallest set of blocks as possible to meet this
              requirement.
            </t>

            <t>
              <cref anchor='AI28' source='TH'>
                Is the DS supposed to vet all blocks first or proceed to
                the first error? Or do all blocks and return an array
                of errors? (This last one is a no-go.) Also, if we do
                the vet first, what happens if a CHUNK_WRITE comes in
                after the vetting? Are we to lock the file during this
                process. Even if we do that, we still have the issue
                of multiple DSes.
              </cref>
            </t>
          </section>

          <section anchor='update_header' numbered='true' removeInRFC='false' toc='exclude'>
            <name>Updating the Header Only</name>
            <t>
              Some erasure encoding types keep their blocks in plain text and
              have parity blocks in order to provide integrity. A common
              configuration for Reed Solomon is 4 active blocks, 2
              parity blocks, and 2 spares. Assuming 4kB data blocks,
              then each payload delivers 16kB of data and 8kB of parity.
              If the application modifies the first data block, then
              all that needs to change is the first active block and the
              two parity blocks in the payload.
            </t>
            <t>
              In any other approach, only 12kB of the total 24kB has to
              be written to storage. If that is attempted in the Flexible
              Files Version 2 Layout Type, then the payload will be deemed
              as inconsistent. The reason for this is that the change_id
              for the unmodified blocks will not match those of the
              modified blocks.
            </t>
            <t>
              The CHUNK_WRITE_FLAGS_UPDATE_HEADER_ONLY flag in cw_flags
              can be used to save
              the transmission of the blocks. If it is set, then
              the cw_chunk is ignored. It <bcp14>MUST</bcp14> be
              empty. The client <bcp14>MUST</bcp14> only
              modify both the cw_crc and the cwa_owner.co_change_id
              fields in this case. The cw_crc <bcp14>MUST</bcp14>
              change as the cwa_owner.co_change_id has been modified
              (see <xref target='calculating_crc' />).
            </t>
            <t>
              For the
              purpose of computing the activation state of the block,
              The data server <bcp14>MUST</bcp14> treat this as
              an overwrite. Thus, in the response, co_activated
              <bcp14>MUST</bcp14> be false.
            </t>
          </section>
        </section>
      </section>

      <section anchor='ROLLBACK_OPEN' numbered='true' removeInRFC='false' toc='default'>
        <name>Operation 77: ROLLBACK_OPEN - Reserve a byte range for writing</name>
        <section anchor='ROLLBACK_OPEN4args' numbered='true' removeInRFC='false' toc='exclude'>
          <name>ARGUMENTS</name>
          <figure anchor='code_ROLLBACK_OPEN4args'>
            <sourcecode type='xdr'>
/// struct ROLLBACK_OPEN4args {
///     /* CURRENT_FH: file */
///     stateid4        roa_stateid;
///     ffv2_key4       roa_key;
///     uint32_t        roa_client_id;
/// };
            </sourcecode>
          </figure>
        </section>

        <section anchor='ROLLBACK_OPEN4res' numbered='true' removeInRFC='false' toc='exclude'>
          <name>RESULTS</name>
          <figure anchor='code_ROLLBACK_OPEN4res'>
            <sourcecode type='xdr'>
/// union ROLLBACK_OPEN4res switch (nfsstat4 ror_status) {
///     case NFS4_OK:
///         /* New CURRENT_FH: opened client file */
///     default:
///         void;
/// };
            </sourcecode>
          </figure>
        </section>

        <section anchor='ROLLBACK_OPEN4_desc' numbered='true' removeInRFC='false' toc='exclude'>
          <name>DESCRIPTION</name>
          <t>
            ROLLBACK_OPEN is a new operation to open a per client file for staging
            of chunks to the data file and populates 
            the current filehandle for it. As the reservation
            file is not visible in the server namespace, the client
            <bcp14>MUST</bcp14> issue a GETFH (see Section
            18.8 of <xref target='RFC8881' />) to get the filehandle.
            The client file <bcp14>MUST</bcp14> have the exact
            same authorization as the data file (see Section 2.8.1 of <xref target='RFC8881' />),
            which means the attributes mode, owner,
            owner_group, acl, dacl, and sacl <bcp14>MUST</bcp14> track those
            of the file. I.e., they <bcp14>MUST NOT</bcp14> be modified by
            SETATTR on the client file and if they are modified on
            the data file, they <bcp14>MUST</bcp14> be modified equivalently
            on the client file. Finally, the values of time_access,
            time_backup, time_create, time_metadata, time_modify, and change
            <bcp14>MUST</bcp14> initially be those of the data file, but they
            <bcp14>MUST</bcp14> be tracked separately from the data file.
          </t>
          <t>
            ROLLBACK_OPEN <bcp14>MUST</bcp14> check for write access just like
            the WRITE operation. I.e., if the owner does not have write
            permissions, if it is a read-only filesystem, etc, the
            appropriate error <bcp14>MUST</bcp14> be returned to the
            ROLLBACK_OPEN operation.
          </t>
          <t>
            The metadata server <bcp14>MUST</bcp14> persist the roa_key and the roa_client_id
            in order to authenticate subsequent operations on the client file.
            These are not visible attributes for the client file. The
            metadata server <bcp14>MUST</bcp14> not reveal the roa_key in a GETATTR result.
            If the metadata server loses the roa_key, then the data server <bcp14>MUST</bcp14>
            allow for local administrative action to close the client file
            Note that such means are beyond the scope of this document.
          </t>
          <t>
            The ra_stateid follows the rules for a WRITE request
            for pNFS (see Section 2.3.1 of <xref target='RFC8435' />).
            I.e., an anonymous stateid is presented.
          </t>
          <t>
            ROLLBACK_OPEN can also be used to recover a client file. The
            user has to have access to the underlying file in order to recover
            the reservation. If the client file already exists, 
            the roa_key <bcp14>MUST</bcp14>
            match that which was persisted in the original ROLLBACK_OPEN operation to create the
            client file. The roa_client_id <bcp14>MUST</bcp14> also match that of
            which was persisted in the original ROLLBACK_OPEN operation to create the
            client file.
          </t>
          <t>
            If the roa_key does not match that peristed, then the server
            <bcp14>MUST</bcp14> send back the error NFS4ERR_PERM. The client can use
            GETATTR to determine if this was due to normal file system semantics or
            a mismatched ffv2_key4.
          </t>
        </section>
      </section>

      <section anchor='ROLLBACK_LIST' numbered='true' removeInRFC='false' toc='default'>
        <name>Operation 78: ROLLBACK_LIST - Get information on a byte range for writing</name>
        <section anchor='ROLLBACK_LIST4args' numbered='true' removeInRFC='false' toc='exclude'>
          <name>ARGUMENTS</name>
          <figure anchor='code_ROLLBACK_LIST4args'>
            <sourcecode type='xdr'>
/// struct ROLLBACK_LIST4args {
///     /* CURRENT_FH: file */
///     stateid4        ria_stateid;
/// };
            </sourcecode>
          </figure>
        </section>

        <section anchor='ROLLBACK_LIST4res' numbered='true' removeInRFC='false' toc='exclude'>
          <name>RESULTS</name>
          <figure anchor='code_rollback_info4'>
            <sourcecode type='xdr'>
/// struct rollback_info4 {
///     uint32_t       ri_client_id;
///     nfs_fh4        ri_fh;
/// };
            </sourcecode>
          </figure>

          <figure anchor='code_ROLLBACK_LIST4resok'>
            <sourcecode type='xdr'>
/// struct ROLLBACK_LIST4resok {
///     rollback_info4  rlr_rollbacks&lt;&gt;;
/// };
            </sourcecode>
          </figure>

          <figure anchor='code_ROLLBACK_LIST4res'>
            <sourcecode type='xdr'>
/// union ROLLBACK_LIST4res switch (nfsstat4 rlr_status) {
///     case NFS4_OK:
///         ROLLBACK_LIST4resok         rlr_resok4;
///     default:
///         void;
/// };
            </sourcecode>
          </figure>
        </section>

        <section anchor='ROLLBACK_LIST4_desc' numbered='true' removeInRFC='false' toc='exclude'>
          <name>DESCRIPTION</name>
          <t>
            ROLLBACK_LIST is a new operation to list the open client rollback files
            for the current filehandle.
            As shown in <xref target='code_ROLLBACK_LIST4args' />, a stateid
            that follows the rules of <xref target='ROLLBACK_OPEN4_desc' /> <bcp14>MUST</bcp14>
            be presented.
          </t>
          <t>
            The result is an array of rollback_info4 (see <xref target='code_rollback_info4' />).
            The ri_client_id allows the metadata
            server to determine which reservations belonged to a dead client.
            The ffv2_key4 associated with the reservation file <bcp14>MUST NOT</bcp14>
            be sent back in the results.
          </t>
        </section>
      </section>

      <section anchor='ROLLBACK_CLOSE' numbered='true' removeInRFC='false' toc='default'>
        <name>Operation 80: ROLLBACK_CLOSE - Release reservation on a byte range for writing</name>
        <section anchor='ROLLBACK_CLOSE4args' numbered='true' removeInRFC='false' toc='exclude'>
          <name>ARGUMENTS</name>
          <figure anchor='code_ROLLBACK_CLOSE4args'>
            <sourcecode type='xdr'>
/// struct ROLLBACK_CLOSE4args {
///     /* CURRENT_FH: file */
///     stateid4        rra_stateid;
///     uint32_t        rra_reservation_id;
///     ffv2_key4       rra_key;
/// };
            </sourcecode>
          </figure>
        </section>

        <section anchor='ROLLBACK_CLOSE4res' numbered='true' removeInRFC='false' toc='exclude'>
          <name>RESULTS</name>

          <figure anchor='code_ROLLBACK_CLOSE4res'>
            <sourcecode type='xdr'>
/// struct ROLLBACK_CLOSE4res {
///     nfsstat4 rrr_status;
/// };
            </sourcecode>
          </figure>
        </section>

        <section anchor='ROLLBACK_CLOSE4_desc' numbered='true' removeInRFC='false' toc='exclude'>
          <name>DESCRIPTION</name>
          <t>
            ROLLBACK_CLOSE is a new operation to release a reservation on a file. The
            user has to have access to the underlying file in order to release
            the reservation. For the given reservation identified by rra_reservation_id
            (see <xref target='code_ROLLBACK_CLOSE4args' />), the rra_key <bcp14>MUST</bcp14>
            match that which was persisted in the original ROLLBACK_OPEN operation to create the
            reservation.
            As shown in <xref target='code_ROLLBACK_CLOSE4args' />, a stateid
            that follows the rules of <xref target='ROLLBACK_OPEN4_desc' /> <bcp14>MUST</bcp14>
            be presented.
          </t>
          <t>
            If there is no matching reservation for the rra_reservation_id, then
            the server <bcp14>MUST</bcp14> send back the error NFS4ERR_NOENT. If the
            rra_key does not match that peristed, then the server <bcp14>MUST</bcp14> send back the error
            NFS4ERR_PERM. The client can use GETATTR to determine if this was due
            to normal file system semantics or a mismatched ffv2_key4.
          </t>
          <t>
            The state of fattr4reserved_state for the reservation file <bcp14>MUST</bcp14>
            be persisted to NFS4_ROLLBACK_OPEND_RELEASED.
          </t>
        </section>
      </section>
    </section>

    <section anchor='cb_ops' numbered='true' removeInRFC='false' toc='default'>
      <name>New NFSv4.2 Callback Operations</name>
      <section anchor='CB_CHUNK_REPAIR' numbered='true' removeInRFC='false' toc='default'>
        <name>Operation 16: CB_CHUNK_REPAIR - Repair a reservation of a byte range for writing</name>
        <section anchor='CB_CHUNK_REPAIR4args' numbered='true' removeInRFC='false' toc='exclude'>
          <name>ARGUMENTS</name>
          <figure anchor='code_CB_CHUNK_REPAIR4args'>
            <sourcecode type='xdr'>
/// struct CB_CHUNK_REPAIR4args {
///     /* CURRENT_FH: file */
///     stateid4             crra_stateid;
///     uint32_t             crra_reservation_id;
///     ffv2_key4            crra_key;
///     ffv2_encoding_type4  crra_type;
/// };
            </sourcecode>
          </figure>
        </section>

        <section anchor='CB_CHUNK_REPAIR4res' numbered='true' removeInRFC='false' toc='exclude'>
          <name>RESULTS</name>

          <figure anchor='code_CB_CHUNK_REPAIR4res'>
            <sourcecode type='xdr'>
/// struct CB_CHUNK_REPAIR4res {
///     nfsstat4 crrr_status;
/// };
            </sourcecode>
          </figure>
        </section>

        <section anchor='CB_CHUNK_REPAIR4_desc' numbered='true' removeInRFC='false' toc='exclude'>
          <name>DESCRIPTION</name>
          <t>
            CB_CHUNK_REPAIR is a new callback operation to request that the client repair a reservation
            on a file. The user has to have access to the underlying file in order to release
            the reservation. For the given reservation identified by rra_reservation_id
            (see <xref target='code_CB_CHUNK_REPAIR4args' />), the crra_key <bcp14>MUST</bcp14>
            match that which was persisted in the original ROLLBACK_OPEN operation to create the
            reservation.
            As shown in <xref target='code_CB_CHUNK_REPAIR4args' />, a stateid
            that follows the rules of <xref target='ROLLBACK_OPEN4_desc' /> <bcp14>MUST</bcp14>
            be presented.
          </t>
          <t>
            If the client does not support the ROLLBACK_OPEN family of operations, it
            <bcp14>MUST</bcp14> return an error of NFS4ERR_NOTSUPP. Note that
            this is most likely going to occur as in this case it will not
            support CB_CHUNK_REPAIR. If the client does not support the
            crra_type for the erasure encoding type, then it <bcp14>MUST</bcp14>
            return an error of NFS4ERR_ENCODING_NOT_SUPPORTED.
          </t>
        </section>
      </section>
    </section>

    <section anchor='xdr_desc' numbered='true' removeInRFC='false' toc='default'>
      <name>Extraction of XDR</name>
      <t>
        This document contains the external data representation (XDR)
        <xref target='RFC4506' /> description of
        the Flexible File Version 2 Layout Type.  The XDR description is embedded in this
        document in a way that makes it simple for the reader to extract
        into a ready-to-compile form.  The reader can feed this document
        into the following shell script to produce the machine readable
        XDR description of the new flags:
      </t>
      <sourcecode type='xdr'>
#!/bin/sh
grep '^ *///' $* | sed 's?^ */// ??' | sed 's?^ *///$??'
      </sourcecode>
      <t>
        That is, if the above script is stored in a file called 'extract.sh', and
        this document is in a file called 'spec.txt', then the reader can do:
      </t>
      <sourcecode type='xdr'>
sh extract.sh &lt; spec.txt &gt; erasure_coding_prot.x
      </sourcecode>
      <t>
        The effect of the script is to remove leading white space from each
        line, plus a sentinel sequence of '///'.  XDR descriptions with the
        sentinel sequence are embedded throughout the document.
      </t>
      <t>
        Note that the XDR code contained in this document depends on types
        from the NFSv4.2 nfs4_prot.x file (generated from
        <xref target='RFC7863' />)
        and the Flexible File Layout Type flexfiles.x file (generated from
        <xref target='RFC8435' />).
        This includes both nfs types that end with a 4, such as offset4,
        length4, etc., as well as more generic types such as uint32_t and
        uint64_t.
      </t>
      <t>
        While the XDR can be appended to that from
        <xref target='RFC7863' />,
        the various code snippets belong in their respective areas of
        that XDR.
      </t>
    </section>

    <section anchor='sec_security' numbered='true' removeInRFC='false' toc='default'>
      <name>Security Considerations</name>
      <t>
        This document has the same security considerations as both Flexible File
        Layout Type version 1 (see Section 15 of <xref target='RFC8435' />)
        and NFSv4.2 (see Section 17 of <xref target='RFC7862' />).
      </t>
    </section>

    <section anchor='sec_iana' numbered='true' removeInRFC='false' toc='default'>
      <name>IANA Considerations</name>

      <section anchor='sec_iana_layouts' numbered='true' removeInRFC='false' toc='default'>
        <name>pNFS Layout Types Registry</name>
        <t>
          <xref target='RFC8881' />
          introduced the 'pNFS Layout Types Registry'; new layout type
          numbers in this registry need to be assigned by IANA.  This document
          defines the protocol associated with an existing layout type number:
          LAYOUT4_FLEX_FILES_V2 (see <xref target='layoutlist' />).
        </t>

        <table anchor='layoutlist'>
          <name>Layout Type Assignments</name>
          <thead>
            <tr>
              <th>Layout Type Name</th>
              <th>Value</th>
              <th>RFC</th>
              <th>How</th>
              <th>Minor Versions</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>LAYOUT4_FLEX_FILES_V2</td> <td>0x6</td> <td>RFCTBD10</td> <td>L</td> <td>1</td>
            </tr>
          </tbody>
        </table>
      </section>

      <section anchor='sec_iana_recallable' numbered='true' removeInRFC='false' toc='default'>
        <name>NFSv4 Recallable Object Types Registry</name>
        <t>
          <xref target='RFC8881' /> also
          introduced the 'NFSv4 Recallable Object Types Registry'.  This document
          defines new recallable objects for RCA4_TYPE_MASK_FFV2_LAYOUT_MIN and
          RCA4_TYPE_MASK_FFV2_LAYOUT_MAX (see <xref target='recalllist' />).
        </t>

        <table anchor='recalllist'>
          <name>Recallable Object Type Assignments</name>
          <thead>
            <tr>
              <th>Recallable Object Type Name</th>
              <th>Value</th>
              <th>RFC</th>
              <th>How</th>
              <th>Minor Versions</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>RCA4_TYPE_MASK_FFV2_LAYOUT_MIN</td> <td>20</td> <td>RFCTBD10</td> <td>L</td> <td>1</td>
            </tr>
            <tr>
              <td>RCA4_TYPE_MASK_FFV2_LAYOUT_MAX</td> <td>21</td> <td>RFCTBD10</td> <td>L</td> <td>1</td>
            </tr>
          </tbody>
        </table>
      </section>

      <section anchor='sec_iana_encoding' numbered='true' removeInRFC='false' toc='default'>
        <name>Flexible File Version 2 Layout Type Erasure Encoding Type Registry</name>
        <t>
          This document introduces the 'Flexible File Version 2 Layout Type Erasure Encoding Type Registry'. This
          document defines the FFV2_ENCODING_MIRRORED type for Client-Side Mirroring
          (see <xref target='erasure_encoding' />).
        </t>

        <table anchor='erasure_encoding'>
          <name>Flexible File Version 2 Layout Type Erasure Encoding Type Assignments</name>
          <thead>
            <tr>
              <th>Erasure Encoding Type Name</th>
              <th>Value</th>
              <th>RFC</th>
              <th>How</th>
              <th>Minor Versions</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>FFV2_ENCODING_MIRRORED</td> <td>1</td> <td>RFCTBD10</td> <td>L</td> <td>2</td>
            </tr>
          </tbody>
        </table>
      </section>
    </section>

  </middle>

  <back>

    <references>
      <name>References</name>

      <references>
      <name>Normative References</name>
        <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
           href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml'/>
        <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
           href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4506.xml'/>
        <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
           href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7530.xml'/>
        <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
           href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7862.xml'/>
        <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
           href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7863.xml'/>
        <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
           href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml'/>
        <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
           href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8178.xml'/>
        <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
           href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8435.xml'/>
        <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
           href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8881.xml'/>
      </references>

      <references>
      <name>Informative References</name>
        <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
           href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1813.xml'/>
        <reference anchor='Plank97' target='http://web.eecs.utk.edu/~jplank/plank/papers/CS-96-332.html'>
          <front>
            <title>A Tutorial on Reed-Solomon Coding for Fault-Tolerance in RAID-like System</title>
            <author fullname='James S. Plank' initials='J.' surname='Plank'>
            </author>
            <date month='September' year='1997'/>
          </front>
        </reference>
      </references>
    </references>

    <section numbered='true' removeInRFC='false' toc='default'>
      <name>Acknowledgments</name>
      <t>
        The following from Hammerspace were instrumental in driving
        Flexible File Version 2 Layout Type: David Flynn, Trond Myklebust,
        Tom Haynes, Didier Feron,
        Jean-Pierre Monchanin, Pierre Evenou, and Brian Pawlowski.
      </t>
      <t>
        Christoph Helwig was instrumental in making sure Flexible File
        Version 2 Layout Type
        was applicable to more than one Erasure Encoding Type.
      </t>
      <t>
        Robin Battey reviewed the Erasure Encoding approach
        and provided expert feedback.
      </t>
    </section>

  </back>

</rfc>
