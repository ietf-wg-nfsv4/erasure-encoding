<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>

<rfc
 category="std"
 docName="draft-haynes-nfsv4-erasure-encoding-VERSIONVAR"
 ipr="trust200902"
 obsoletes=""
 scripts="Common,Latin"
 sortRefs="true"
 submissionType="IETF"
 symRefs="true"
 tocDepth="3"
 tocInclude="true"
 version="3"
 xml:lang="en">

<front>
  <title abbrev="erasure encoding">
    Erasure Encoding of Files in NFSv4.2
  </title>
  <seriesInfo name="Internet-Draft" value="draft-haynes-nfsv4-erasure-encoding-VERSIONVAR"/>
  <author fullname="Thomas Haynes" initials="T." surname="Haynes">
    <organization abbrev="Hammerspace">Hammerspace</organization>
    <address>
      <email>loghyr@hammerspace.com</email>
    </address>
  </author>
  <date year="YEARVAR" month="MONTHVAR" day="DAYVAR"/>
  <area>Transport</area>
  <workgroup>Network File System Version 4</workgroup>
  <keyword>NFSv4</keyword>
  <abstract>
    <t>
      Parallel NFS (pNFS) allows a separation between the metadata (onto
      a metadata server) and data (onto a storage device) for a file.
      The flexible file layout type version 2 is defined in this document
      as an extension to pNFS that allows the use of storage devices that
      require only a limited degree of interaction with the metadata
      server and use already-existing protocols.  Data replication is
      also added to provide integrity.
    </t>
  </abstract>

  <note removeInRFC="true">
    <t>
      Discussion of this draft takes place
      on the NFSv4 working group mailing list (nfsv4@ietf.org),
      which is archived at
      <eref target="https://mailarchive.ietf.org/arch/browse/nfsv4/"/>.
      Working Group information can be found at
      <eref target="https://datatracker.ietf.org/wg/nfsv4/about/"/>.
    </t>
  </note>

  <note removeInRFC="true">
    <t>
      This draft starts sparse and will be filled in as details are
      ironed out. For example, WRITE_BLOCK in <xref target='WRITE_BLOCK' />
      is presented as being WRITE (see Section 18.32 of <xref
      target="RFC8881" format="default" sectionFormat="of" />) plus
      some semantical changes. In the first draft, we simply explain the
      semantical changes. As these are accepted by the knowlegable reviewers,
      we will flesh out the WRITE_BLOCK section to include sub-sections more
      akin to 18.32.3 and 18.32.4 of <xref
      target="RFC8881" format="default" sectionFormat="of" />.
    </t>
  </note>
</front>

<middle>

  <section anchor="sec_intro" numbered="true" removeInRFC="false" toc="default">
    <name>Introduction</name>
    <t>
      In Parallel NFS (pNFS) (see Section 12 of
      <xref target="RFC8881" format="default" sectionFormat="of" />), the metadata server returns layout type
      structures that describe where file data is located.  There are
      different layout types for different storage systems and methods
      of arranging data on storage devices.  <xref target="RFC8435"
      format="default" sectionFormat="of" /> defined the flexible
      file layout type used with file-based data servers that are
      accessed using the NFS protocols: NFSv3 <xref target="RFC1813"
      format="default" sectionFormat="of" />, NFSv4.0 <xref
      target="RFC7530" format="default" sectionFormat="of" />, NFSv4.1
      <xref target="RFC8881" format="default" sectionFormat="of" />, and
      NFSv4.2 <xref target="RFC7862" format="default" sectionFormat="of" />.
    </t>

    <t>
      The Client Side Mirroring (see Section 8 of <xref target="RFC8435"
      format="default" sectionFormat="of"/>), introduced with the first
      version of the flex file layout type, provides for replication
      of data but does not provide for integrity of data. In the event
      of an error, an user would be able to repair the file by silvering
      the mirror contents. I.e., they would pick one of the mirror
      instances and replicate it to the other instance locations.
    </t>

    <t>
      However, lacking integrity checks, silent corruptions are not able
      to be detected and the choice of what constitutes the good copy
      is difficult.  This document updates the flexible file layout type
      to version 2 by providing data integrity for erasure encoding.
      It introduces new variants of COMMIT (see Section 18.3 of <xref
      target="RFC8881" format="default" sectionFormat="of" />) , READ
      (see Section 18.22 of <xref target="RFC8881" format="default"
      sectionFormat="of" />) , and WRITE (see Section 18.32 of <xref
      target="RFC8881" format="default" sectionFormat="of" />) to allow
      for the transmission of integrity checking.
    </t>

    <t>
      Using the process detailed in <xref target="RFC8178" format="default"
      sectionFormat="of"/>, the revisions in this document become an
      extension of NFSv4.2 <xref target="RFC7862" format="default"
      sectionFormat="of"/>. They are built on top of the external data
      representation (XDR) <xref target="RFC4506" format="default"
      sectionFormat="of"/> generated from <xref target="RFC7863"
      format="default" sectionFormat="of"/>.
    </t>

    <section anchor="sec_defs" numbered="true" removeInRFC="false" toc="default">
      <name>Definitions</name>
      <dl newline="false" spacing="normal">
        <dt>Client Side Mirroring:</dt>
        <dd>
          A file based replication method where copies are maintained
          in parallel.
        </dd>

        <dt>data block:</dt>
        <dd>
          A block of data in the client's cache for a file.
        </dd>

        <dt>Erasure Encoding:</dt>
        <dd>
          A data protection scheme where a block of data is replicated
          into fragments and additional redundant fragments are added
          to achieve parity. The new blocks are stored in different
          locations.
        </dd>

        <dt>Client Side Erasure Encoding:</dt>
        <dd>
          A file based integrity method where copies are maintained
          in parallel.
        </dd>

        <dt>integrity of data:</dt>
        <dd>
          Data integrity refers to the accuracy, consistency, and
          reliability of data throughout its life cycle.
        </dd>

        <dt>projection block:</dt>
        <dd>
          One of the resulting blocks to be exchanged with a data
          server after a transformation has been applied to
          a data block.
        </dd>

        <dt>replication of data:</dt>
        <dd>
          Data replication is making and storing multiple copies
          of data in different locations.
        </dd>

        <dt>write hole:</dt>
        <dd>
          A write hole is a data corruption scenario where either
          two clients are trying to write to the same block or
          one client is overwriting an existing block of data.
        </dd>
      </dl>
    </section>

    <section numbered="true" removeInRFC="false" toc="default">
      <name>Requirements Language</name>
      <t>
        The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
        "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
        NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
        "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
        "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this
        document are to be interpreted as described in BCP&nbsp;14 <xref
        target="RFC2119" format="default" sectionFormat="of"/> <xref
        target="RFC8174" format="default" sectionFormat="of"/> when,
        and only when, they appear in all capitals, as shown here.
      </t>
    </section>
  </section>

  <section numbered="true" removeInRFC="false" toc="default">
    <name>Flexible File Layout Type Version 2</name>

    <t>
      In order to introduce erasure encoding to pNFS, a new layout type
      of LAYOUT4_FLEX_FILES_V2 needs to be defined.  While we could
      define a new layout type per erasure encoding type, there exist
      use cases where multiple erasure encoding types in the same layout.
    </t>

    <t>
      The original layouttype4 introduced in <xref target="RFC8881"
      format="default" sectionFormat="of" /> is modified to as in <xref
      target='code_layout4' />.
    </t>

    <figure anchor='code_layout4'>
      <sourcecode type='xdr'>
       enum layouttype4 {
           LAYOUT4_NFSV4_1_FILES   = 1,
           LAYOUT4_OSD2_OBJECTS    = 2,
           LAYOUT4_BLOCK_VOLUME    = 3,
           LAYOUT4_FLEX_FILES      = 4,
           LAYOUT4_FLEX_FILES_V2   = 5
       };

       struct layout_content4 {
           layouttype4             loc_type;
           opaque                  loc_body&lt;&gt;;
       };

       struct layout4 {
           offset4                 lo_offset;
           length4                 lo_length;
           layoutiomode4           lo_iomode;
           layout_content4         lo_content;
       };
      </sourcecode>
    </figure>

    <t>
      This document defines structures associated with the layouttype4
      value LAYOUT4_FLEX_FILES_V2.  <xref target="RFC8881" format="default"
      sectionFormat="of" /> specifies the loc_body structure as an XDR
      type "opaque".  The opaque layout is uninterpreted by the generic
      pNFS client layers but is interpreted by the flexible file layout
      type implementation.  This section defines the structure of this
      otherwise opaque value, ffv2_layout4.
    </t>

    <section anchor="ffv2_encoding_type" numbered="true" removeInRFC="false" toc="default">
      <name>ffv2_encoding_type</name>

      <figure anchor='code_ffv2_encoding_type'>
        <sourcecode type='xdr'>
   /// enum ffv2_encoding_type {
   ///     FFV2_ENCODING_TYPE_MIRRORED       = 0x1;
   /// };
        </sourcecode>
      </figure>

      <t>
        The ffv2_encoding_type (see <xref target='code_ffv2_encoding_type' />)
        encompasses a new IANA registry for "Flex Files V2 Erasure
        Encoding Type Registry" (see <xref target='sec_iana_encoding' />).
        I.e., instead of defining a new Layout Type for each
        Erasure Encoding, we define a new Erasure Encoding Type.
        Except for FFV2_ENCODING_TYPE_MIRRORED, each of the types
        is expected to employ the new operations in this document.
      </t>

      <t>
        FFV2_ENCODING_TYPE_MIRRORED offers replication of data and
        not integrity of data. As such, it does not need operations
        like WRITE_BLOCK (see <xref target='WRITE_BLOCK' />).
      </t>
    </section>

    <section anchor="ff_flags4" numbered="true" removeInRFC="false" toc="default">
      <name>ff_flags4</name>
      <figure anchor='code_ff_flags4'>
        <sourcecode type='xdr'>
   const FF_FLAGS_NO_LAYOUTCOMMIT   = 0x00000001;
   const FF_FLAGS_NO_IO_THRU_MDS    = 0x00000002;
   const FF_FLAGS_NO_READ_IO        = 0x00000004;
   const FF_FLAGS_WRITE_ONE_MIRROR  = 0x00000008;
   typedef uint32_t            ff_flags4;
        </sourcecode>
      </figure>
      <t>
        ff_flags4 is defined as in Section 5.1 of <xref target="RFC8435"
        format="default" sectionFormat="of"/> and is shown
        in <xref target='code_ff_flags4' /> for reference.
      </t>
    </section>

    <section anchor="ffv2_file_info4" numbered="true" removeInRFC="false" toc="default">
      <name>ffv2_file_info4</name>
      <figure anchor='code_ffv2_file_info4'>
        <sourcecode type='xdr'>
   /// struct ffv2_file_info4 {
   ///     stateid4                fffi_stateid;
   ///     nfs_fh4                 fffi_fh_vers;
   /// };
        </sourcecode>
      </figure>
      <t>
        The ffv2_file_info4 is a new structure to help with
        the stateid issue discussed in Section 5.1
        of <xref target="RFC8435"
        format="default" sectionFormat="of"/>. I.e., in
        version 1 of the flex file layout type, there
        was the singleton ffds_stateid combined with the
        ffds_fh_vers array. I.e., each NFSv4 version has
        its own stateid. In <xref target='code_ffv2_file_info4' />,
        each NFSv4 filehandle has a one-to-one
        correspondence to a stateid.
      </t>
    </section>

    <section anchor="ffv2_ds_flags4" numbered="true" removeInRFC="false" toc="default">
      <name>ffv2_ds_flags4</name>
      <figure anchor='code_ffv2_ds_flags4'>
        <sourcecode type='xdr'>
   /// const FFV2_DS_FLAGS_ACTIVE        = 0x00000001;
   /// const FFV2_DS_FLAGS_SPARE         = 0x00000002;
   /// const FFV2_DS_FLAGS_PARITY        = 0x00000004;
   /// const FFV2_DS_FLAGS_REPAIR        = 0x00000008;
   /// typedef uint32_t            ffv2_ds_flags4;
        </sourcecode>
      </figure>
      <t>
        The ffv2_layout4 (in <xref target='code_ffv2_ds_flags4' />) flags detail the state of the data servers.
      </t>
    </section>

    <section anchor="ffv2_data_server4" numbered="true" removeInRFC="false" toc="default">
      <name>ffv2_data_server4</name>
      <figure anchor='code_ffv2_data_server4'>
        <sourcecode type='xdr'>
   /// struct ffv2_data_server4 {
   ///     deviceid4               ffds_deviceid;
   ///     uint32_t                ffds_efficiency;
   ///     ffv2_file_info4         ffds_file_info&lt;&gt;;
   ///     fattr4_owner            ffds_user;
   ///     fattr4_owner_group      ffds_group;
   ///     ffv2_ds_flags4          ffds_flags;
   /// };
        </sourcecode>
      </figure>
      <t>
        The ffv2_data_server4 (in <xref target='code_ffv2_data_server4' />) describes
        a data file and how to access it via the different NFS protocols.
      </t>
    </section>

    <section anchor="ffv2_mirror4" numbered="true" removeInRFC="false" toc="default">
      <name>ffv2_mirror4</name>
      <figure anchor='code_ffv2_mirror4'>
        <sourcecode type='xdr'>
   /// struct ffv2_mirror4 {
   ///     ffv2_data_server4       ffm_data_servers&lt;&gt;;
   ///     ffv2_encoding_type      ffm_encoding;
   /// };
        </sourcecode>
      </figure>
      <t>
        The ffv2_mirror4 (in <xref target='code_ffv2_mirror4' />) describes
        the flex file layout version 2 specific fields.
      </t>
    </section>

    <section anchor="ffv2_encoding_data" numbered="true" removeInRFC="false" toc="default">
      <name>ffv2_encoding_data</name>
      <figure anchor='code_ffv2_encoding_data'>
        <sourcecode type='xdr'>
   /// union ffv2_encoding_data switch
   ///         (ffv2_encoding_type fed_type) {
   ///     case FF2_ENCODING_TYPE_MIRRORED:
   ///         void;
   /// };
        </sourcecode>
      </figure>
      <t>
        The ffv2_encoding_data (in <xref target='code_ffv2_encoding_data' />) describes
        erasure encoding type specific fields.
      </t>
    </section>

    <section anchor="ffv2_layout4" numbered="true" removeInRFC="false" toc="default">
      <name>ffv2_layout4</name>
      <figure anchor='code_ffv2_layout4'>
        <sourcecode type='xdr'>
   /// struct ffv2_layout4 {
   ///     length4                 ffl_stripe_unit;
   ///     ffv2_mirror4            ffl_mirrors&lt;&gt;;
   ///     ff_flags4               ffl_flags;
   ///     uint32_t                ffl_stats_collect_hint;
   /// };
        </sourcecode>
      </figure>
      <t>
        The ffv2_layout4 (in <xref target='code_ffv2_layout4' />) describes
        the flex files layout version 2.
      </t>
    </section>

    <section anchor="sec_mix_types" numbered="true" removeInRFC="false" toc="default">
      <name>Mixing of Encoding Types</name>
      <t>
        Note that effectively, multiple encoding types can be present
        in a flex files version 2 layout.  The ffv2_layout4 has an array
        of ffv2_mirror4, each of which has a ffv2_encoding_type.
        The main reason to allow for this is to provide for either the
        assimilation of a non-erasure encoded file to an erasure
        encoded file or the exporting of an erasure encoded file to
        a non-erasure encoded file.
      </t>
      <t>
        Assume there is an additional ffv2_encoding_type of
        FF2_ENCODING_TYPE_REED_SOLOMON and it needs 4 active blocks,
        2 parity blocks, and 2
        spare block. The user wants to actively assimilate a regular
        file. As such, a layout might be as represented in <xref
        target='mixed_layout' />.  As this is an assimilation, most of
        the data reads will be satisfied by READ (see Section 18.22 of
        <xref target="RFC8881" format="default" sectionFormat="of" />)
        calls to index 0. However, as this is also an active file,
        there could also be READ_BLOCK (see <xref target='READ_BLOCK' />)
        calls to the other indexes.
      </t>
      <t>
        <cref anchor="AI12" source="TH">The figure is two data structures together?</cref>
      </t>
      <t>
        <cref anchor="AI14" source="TH">ACTIVE always has the same mirror index</cref>
      </t>
      <t>
        <cref anchor="AI15" source="TH">SPARE might never have the same mirror index</cref>
      </t>
      <t>
        <cref anchor="AI16" source="TH">Need term for set of projections</cref>
      </t>
      <figure anchor='mixed_layout'>
        <artwork>
         +--------------------------------------------------+
         | ffv2_layout4:                                    |
         +--------------------------------------------------+
         |     ffl_mirrors[0]:                              |
         |         ffm_data_servers:                        |
         |             ffv2_data_server4[0]                 |
         |                 ffds_flags: 0                    |
         |         ffm_encoding: FF2_ENCODING_TYPE_MIRRORED |
         +--------------------------------------------------+
         |     ffl_mirrors[1]:                              |
         |         ffm_data_servers:                        |
         |             ffv2_data_server4[0]                 |
         |                 ffds_flags: FFV2_DS_FLAGS_ACTIVE |
         |             ffv2_data_server4[1]                 |
         |                 ffds_flags: FFV2_DS_FLAGS_ACTIVE |
         |             ffv2_data_server4[2]                 |
         |                 ffds_flags: FFV2_DS_FLAGS_ACTIVE |
         |             ffv2_data_server4[3]                 |
         |                 ffds_flags: FFV2_DS_FLAGS_ACTIVE |
         |             ffv2_data_server4[4]                 |
         |                 ffds_flags: FFV2_DS_FLAGS_PARITY |
         |             ffv2_data_server4[5]                 |
         |                 ffds_flags: FFV2_DS_FLAGS_PARITY |
         |             ffv2_data_server4[6]                 |
         |                 ffds_flags: FFV2_DS_FLAGS_SPARE  |
         |             ffv2_data_server4[7]                 |
         |                 ffds_flags: FFV2_DS_FLAGS_SPARE  |
         |     ffm_encoding: FF2_ENCODING_TYPE_REED_SOLOMON |
         +--------------------------------------------------+
        </artwork>
      </figure>
      <t>
        When performing I/O via a FFV2_ENCODING_TYPE_MIRRORED encoding
        type, the non-transformed data will be used, Whereas with
        other encoding types, the projected header and payload will
        be sent. Further, when reading data from the instance files,
        the client <bcp14>MUST</bcp14> be prepared to have one of the
        encoding types supply data and the other type not to supply
        data. I.e., the READ_BLOCK call might return rlr_eof set to true
        (see <xref target='code_READ_BLOCK4resok' />),
        which indicates that there is no data, where the  READ call might
        return eof to be false, which indicates that there is data. The
        client <bcp14>MUST</bcp14> determine that there is in fact data.
      </t>
      <t>
        An example use case is the active assimilation of a file to
        ensure integrity. As the client is helping to translated the
        file to the new encoding scheme, it is actively modifying the
        file. As such, it might be sequentially reading the file in
        order to translate. The READ call would be returning data and
        the READ_BLOCK would not be returning data. As the client
        overwrites the file, the WRITE call and the WRITE_BLOCK
        call would both have data sent. Finally, if the client
        read back a section which had been modified earlier, both
        the READ and READ_BLOCK calls would return data.
      </t>
    </section>
  </section>

  <section anchor="sec_erasure_encoding" numbered="true" removeInRFC="false" toc="default">
    <name>Erasure Encoding</name>
    <t>
      Erasure Encoding takes an data block and transforms it to
      send to the data servers (see <xref target='encoding_projection' />). It
      generates a projection header and payload per data server. The header is metadata
      information for the payload. The
      change_id is an unique identifier generated by the client to describe
      the current write transaction. The client_id is an unique identifier
      assigned by the metadata server to describe which client is making
      the current write transaction. The id describes the projection id. The eff_len
      is the length of the data within the block. Finally, the crc32 is
      the 32 bit crc calculation of the projection header (with the crc32
      field being 0) and the projection payload. By combining the two
      parts of the projection, integrity is ensured for both the
      parts.
    </t>
    <t>
      The set of projection payload contains redundancy which will allow
      the erasure encoding type algorithm to repair payload
      blocks in the projection as it is transformed back to a data block (see
      <xref target='decoding_projection' />).
    </t>

    <section anchor="sec_encoding_projection" numbered="true" removeInRFC="false" toc="default">
      <name>Encoding a Projection</name>

      <figure anchor='encoding_projection'>
        <artwork>
                      +-----------------+
                      |  data block     |
                      +-----------------+
                      |                 |
                      | 3kB data        |
                      |                 |
                      +-----------------+
                      | 1kB empty       |
                      +-------+---------+
                              |
                              |
       +----------------------+-----------------------+
       |      Erasure Encoding (Transform Forward)    |
       +----+-------------------------------------+---+
            |                                     |
            |                                     |
        +---+----------------+         +----------+---------+
        | PROJECTION HEADER  |         | PROJECTION HEADER  |
        +--------------------+         +--------------------+
        | change_id: 3       |         | change_id: 3       |
        | client_id: 6       |         | client_id: 6       |
        | id       : 0       |         | id       : 5       |
        | eff_len  : 3kB     |  ...    | eff_len  : 3kB     |
        | crc32    :         |         | crc32    :         |
        +--------------------+         +--------------------+
        | PROJECTION PAYLOAD |         | PROJECTION PAYLOAD |
        +--------------------+         +--------------------+
        | Data               |         | Data               |
        +--------------------+         +--------------------+
             Data Server 1                 Data Server 6
        </artwork>
      </figure>

      <t>
        Each data block of the file resident in the client's cache of the
        file will be encoded into N different projection payloads to be
        sent to the data servers as shown in <xref target='encoding_projection' />.
        As WRITE_BLOCK (see <xref target='WRITE_BLOCK' />) can encode
        multiple write_block4 into a single transaction, a more accurate
        description of a WRITE_BLOCK might be as in <xref target='example_WRITE_BLOCK_args_1' />.
      </t>

      <figure anchor='example_WRITE_BLOCK_args_1'>
        <artwork>
        +------------------------------------+
        | WRITE_BLOCK4args                   |
        +------------------------------------+
        | wba_stateid: 1ef3                  |
        | wba_offset: 4k                     |
        | wba_stable: FILE_SYNC4             |
        | wba_id: 0                          |
        | wba_owner:                         |
        +----------+-------------------------+
        |          | bo_change_id: 3         |
        |          | bo_client_id: 6         |
        +----------+-------------------------+
        | wba_block[0]:                      |
        +----------+-------------------------+
        |          | wb_crc    :  32ef89     |
        |          | wb_block  :  ......     |
        +----------+--+----------------------+
        |             | wb_block_len  : 4kB  |
        |             | wb_block_val  :      |
        +----------+--+----------------------+
        | wba_block[1]:                      |
        +----------+-------------------------+
        |          | wb_crc    :  56fa89     |
        |          | wb_block  :  ......     |
        +----------+--+----------------------+
        |             | wb_block_len  : 4kB  |
        |             | wb_block_val  :      |
        +----------+--+----------------------+
        | wba_block[2]:                      |
        +----------+-------------------------+
        |          | wb_crc    :  7693af     |
        |          | wb_block  :  ......     |
        +----------+--+----------------------+
        |             | wb_block_len  : 3kB  |
        |             | wb_block_val  :      |
        +----------+--+----------------------+
        </artwork>
      </figure>

      <t>
        <cref anchor="AI13" source="DF">pay attention to the 128 bits alignment for wb_block_val</cref>
      </t>

      <t>
        This describes a 11kB write of data from an offset of 4kB in the file.
        Instead of presenting a wb_effective_len, we rely on the XDR decoding
        of wb_block (see <xref target='code_write_block4' />) to create
        a data structure as in <xref target='c_code_write_block4' />.
        I.e., an opaque will have both "_len" and "_data" generated fields.
        Note that each data server of the N will be sent a corresponding
        array of write_block4. As each block shares the wba_owner, it is only
        presented once. I.e., the data server will be able to construct the
        projection header for each wba_block from the wba_id, wba_owner,
        wb_block_len, and wb_crc.
      </t>

      <figure anchor='c_code_write_block4'>
        <sourcecode type='c'>
typedef struct {
    uint32_t  wb_crc;
    struct {
        u_int wb_block_len;
        char *wb_block_val;
    } wb_block;
} write_block4;
        </sourcecode>
      </figure>

      <t>
        Assuming that there were no issues, <xref target='example_WRITE_BLOCK_res_1' />
        illustrates the results. The projection id is implicit in the WRITE_BLOCK4args.
      </t>

      <figure anchor='example_WRITE_BLOCK_res_1'>
        <artwork>
        +-------------------------------+
        | WRITE_BLOCK4resok             |
        +-------------------------------+
        | wbr_count: 3                  |
        | wbr_committed: FILE_SYNC4     |
        | wbr_writeverf: f1234abc       |
        | wbr_owners[0]:                |
        +----------+--------------------+
        |          | bo_block_id: 1     |
        |          | bo_change_id: 3    |
        |          | bo_client_id: 6    |
        |          | bo_committed: true |
        +----------+--------------------+
        | wbr_owners[1]:                |
        +----------+--------------------+
        |          | bo_block_id: 2     |
        |          | bo_change_id: 3    |
        |          | bo_client_id: 6    |
        |          | bo_committed: true |
        +----------+--------------------+
        | wbr_owners[2]:                |
        +----------+--------------------+
        |          | bo_block_id: 3     |
        |          | bo_change_id: 3    |
        |          | bo_client_id: 6    |
        |          | bo_committed: true |
        +----------+--------------------+
        </artwork>
      </figure>

      <section anchor="calculating_crc" numbered="true" removeInRFC="false" toc="exclude">
        <name>Calculating the CRC32</name>
        <figure anchor='crc_before_calc'>
          <artwork>
        +---+----------------+
        | PROJECTION HEADER  |
        +--------------------+
        | change_id: 7       |
        | client_id: 6       |
        | id       : 0       |
        | eff_len  : 3kB     |
        | crc32    : 0       |
        +--------------------+
        | PROJECTION PAYLOAD |
        +--------------------+
        | Data               |
        +--------------------+
             Data Server 1
          </artwork>
        </figure>

        <t>
          Assuming the projection header and payload as in <xref target='crc_before_calc' />,
          the crc32 needs to be calculated in order to fill in the wb_crc field. In this
          case, the crc32 is calculated over the 5 fields as shown in the projection
          header and the 3kB of projection payload. In this example, it is calculated
          to be 21de8. The resulting WRITE_BLOCK is shown in <xref target='crc_after_calc' />.
        </t>

        <figure anchor='crc_after_calc'>
          <artwork>
        +------------------------------------+
        | WRITE_BLOCK4args                   |
        +------------------------------------+
        | wba_stateid: 2f04                  |
        | wba_offset: 4k                     |
        | wba_stable: FILE_SYNC4             |
        | wba_id: 0                          |
        | wba_owner:                         |
        +----------+-------------------------+
        |          | bo_change_id: 7         |
        |          | bo_client_id: 6         |
        +----------+-------------------------+
        | wba_block[0]:                      |
        +----------+-------------------------+
        |          | wb_crc    :  21de8      |
        |          | wb_block  :  ......     |
        +----------+--+----------------------+
        |             | wb_block_len  : 3kB  |
        |             | wb_block_val  :      |
        +----------+--+----------------------+
          </artwork>
        </figure>
      </section>
    </section>

    <section anchor="sec_decoding_projection" numbered="true" removeInRFC="false" toc="default">
      <name>Decoding a projection</name>
      <figure anchor='decoding_projection'>
        <artwork>
             Data Server 1                 Data Server 6
        +--------------------+         +--------------------+
        | PROJECTION HEADER  |         | PROJECTION HEADER  |
        +--------------------+         +--------------------+
        | change_id: 1       |         | change_id: 1       |
        | client_id: 6       |         | client_id: 6       |
        | id       : 0       |         | id       : 5       |
        | eff_len  : 3kB     |  ...    | eff_len  : 3kB     |
        | crc32    :         |         | crc32    :         |
        +--------------------+         +--------------------+
        | PROJECTION PAYLOAD |         | PROJECTION PAYLOAD |
        +--------------------+         +--------------------+
        | Data               |         | Data               |
        +---+----------------+         +----------+---------+
            |                                     |
            |                                     |
       +----+-------------------------------------+---+
       |      Erasure Decoding (Transform Reverse)    |
       +----------------------+-----------------------+
                              |
                              |
                      +-------+---------+
                      |  data block     |
                      +-----------------+
                      |                 |
                      | 3kB data        |
                      |                 |
                      +-----------------+
                      | 1kB empty       |
                      +-----------------+
        </artwork>
      </figure>
      <t>
        When reading blocks via a READ_BLOCK operation, the client will decode
        the projection headers and payload into data blocks as shown in
        <xref target='decoding_projection' />. Note that at this time, the
        client could detect issues in the inetgrity of the data. The handling
        and repair are out of the scope of this document and <bcp14>MUST</bcp14>
        be addressed in the document describing each erasure encoding type.
      </t>

      <section anchor="checking_crc" numbered="true" removeInRFC="false" toc="exclude">
        <name>Checking the CRC32</name>

        <figure anchor='crc_on_wire'>
          <artwork>
        +------------------------------------+
        | READ_BLOCK4resok                   |
        +------------------------------------+
        | rbr_eof: false                     |
        | rbr_blocks[0]:                     |
        +----------+-------------------------+
        |          | rb_crc: 21de8           |
        |          | wb_crc    :  21de8      |
        +----------+----+--------------------+
        |               | bo_block_id: 1     |
        |               | bo_change_id: 7    |
        |               | bo_client_id: 6    |
        |               | bo_committed: true |
        +----------+----+--------------------+
        |          | rb_block  :  ......     |
        +----------+--+----------------------+
        |             | rb_block_len  : 3kB  |
        |             | rb_block_val  :      |
        +----------+--+----------------------+
          </artwork>
        </figure>

        <t>
          Assuming the READ_BLOCK results as in <xref target='crc_on_wire' />,
          the crc32 needs to be checked in order to ensure data integrity. Conceptually,
          a projection header and payload can be built as shown in <xref target='crc_checking' />.
          The crc32 is calculated over the 5 fields as shown in the projection
          header and the 3kB of projection payload. In this example, it is calculated
          to be 21de8. Thus this projection for the data server has data integrity.
        </t>

        <figure anchor='crc_checking'>
          <artwork>
        +---+----------------+
        | PROJECTION HEADER  |
        +--------------------+
        | change_id: 7       |
        | client_id: 6       |
        | id       : 0       |
        | eff_len  : 3kB     |
        | crc32    : 0       |
        +--------------------+
        | PROJECTION PAYLOAD |
        +--------------------+
        | Data               |
        +--------------------+
             Data Server 1
          </artwork>
        </figure>

      </section>
    </section>
  </section>

  <section anchor="blocks_commit" numbered="true" removeInRFC="false" toc="default">
    <name>Blocks and Committing</name>
    <t>
      Unlike the regular NFSv4.2 I/O operations, the base unit of I/O in this
      document is the block. The raw data stream is encoded/decoded into
      projection blocks as described in <xref target='sec_erasure_encoding' />.
      Each block has the concept of whether it is committed or not. This is
      crucial in detecting write holes. A write hole occurs either when two
      different clients write to the same block concurrently or when a
      client overwrites exisiting data. In the first scenario, the order
      of writes is not deterministic and can result in a mixture of blocks
      in the projection. In the last scenario, network partitions or client
      restarts can result in partial writes. In both cases, the blocks have
      to be repaired, either by abandoning the new I/O or by sorting out
      the winner. Note that unlike the case of the encoding type detecting
      data integrity issues (see <xref target='sec_decoding_projection'/>),
      the case of write holes is in the scope of this document.
    </t>

    <t>
      What is out of scope of this document is the manner in which the
      data servers implement the semantics of the new operations. I.e.,
      the data servers might be able to leverage the native file system
      to achieve the semantics or it might completely implement a
      multi-file approach to stage WRITE_BLOCK results and then
      shuffle blocks when the COMMIT_BLOCK or ROLLBACK_BLOCK operations
      commit the data.
    </t>

    <section anchor="client_died" numbered="true" removeInRFC="false" toc="default">
      <name>Dead or Partitioned Client</name>
      <t>
        Consider a client which was in the middle of sending WRITE_BLOCK to
        a set of data servers and it crashes. Regardless of
        whether it comes back online or not, the metadata server can
        detect that the client had restarted when it had an outstanding
        LAYOUTIOMODE4_RW on the file. The metadata server can assign
        the file to a repair program, which would basically scan the entire
        file with READ_BLOCK_COMMIT. When it determines that it does not
        have enough projection blocks to rebuild the data block, it can
        determine that the I/O for that data block was not complete and
        throw away the projection blocks.
      </t>
      <t>
        Note that the repair process can throw away the projection blocks
        by using the ROLLBACK_BLOCK operation to unstage the pending written blocks.
      </t>
    </section>

    <section anchor="client_overwrite" numbered="true" removeInRFC="false" toc="default">
      <name>Client Overwrite</name>
      <t>
        Consider a client which gets back conflicting information in the WRITE_BLOCK
        results.  Assume that we had written to 6 data servers with WRITE_BLOCKs
        as in <xref target='example_WRITE_BLOCK_args_2' />. And we get the
        results as in <xref target='example_WRITE_BLOCK_res_2_a' />.
      </t>

      <figure anchor='example_WRITE_BLOCK_args_2'>
        <artwork>
        +------------------------------------+
        | WRITE_BLOCK4args                   |
        +------------------------------------+
        | wba_stateid: 1ef3                  |
        | wba_offset: 4k                     |
        | wba_stable: FILE_SYNC4             |
        | wba_id: 0                          |
        | wba_owner:                         |
        +----------+-------------------------+
        |          | bo_change_id: 3         |
        |          | bo_client_id: 6         |
        +----------+-------------------------+
        | wba_block[0]:                      |
        +----------+-------------------------+
        |          | wb_crc    :  32ef89     |
        |          | wb_block  :  ......     |
        +----------+--+----------------------+
        |             | wb_block_len  : 4kB  |
        |             | wb_block_val  :      |
        +----------+--+----------------------+
        | wba_block[1]:                      |
        +----------+-------------------------+
        |          | wb_crc    :  56fa89     |
        |          | wb_block  :  ......     |
        +----------+--+----------------------+
        |             | wb_block_len  : 4kB  |
        |             | wb_block_val  :      |
        +----------+--+----------------------+
        </artwork>
      </figure>

      <t>
        <xref target='example_WRITE_BLOCK_res_2_a' /> shows that the
        first block was an overwrite and a commit has to be done in order
        for the newly written block to be returned in a READ_BLOCK. Assume
        that the next four data servers had the same type of response.
      </t>

      <figure anchor='example_WRITE_BLOCK_res_2_a'>
        <artwork>
                Data Server 1
        +--------------------------------+
        | WRITE_BLOCK4resok              |
        +--------------------------------+
        | wbr_count: 3                   |
        | wbr_committed: FILE_SYNC4      |
        | wbr_writeverf: f1234abc        |
        | wbr_owners[0]:                 |
        +----------+---------------------+
        |          | bo_block_id: 1      |
        |          | bo_change_id: 2     |
        |          | bo_client_id: 6     |
        |          | bo_committed: true  |
        +----------+---------------------+
        | wbr_owners[1]:                 |
        +----------+---------------------+
        |          | bo_block_id: 1      |
        |          | bo_change_id: 3     |
        |          | bo_client_id: 6     |
        |          | bo_committed: false |
        +----------+---------------------+
        | wbr_owners[2]:                 |
        +----------+---------------------+
        |          | bo_block_id: 3      |
        |          | bo_change_id: 3     |
        |          | bo_client_id: 6     |
        |          | bo_committed: true  |
        +----------+---------------------+
        </artwork>
      </figure>

      <t>
        But assume that data server 4 does not respond to the WRITE_BLOCK
        operation. While the client can detect this and send the WRITE_BLOCK
        to any data server marked as FFV2_DS_FLAGS_SPARE, it might decide
        to see if the data server did in fact do the transaction. It might
        also be the case that there are no data servers marked as
        FFV2_DS_FLAGS_SPARE.  The client issues a READ_BLOCK_COMMIT
        (see <xref target='example_READ_BLOCK_COMMIT_args_1' />)
        and gets the results in <xref target='example_READ_BLOCK_COMMIT_res_2_b' />.
        This indicates that data server 4 did not get the WRITE_BLOCK
        request. 
      </t>

      <t>
        In general, the client can either resend the WRITE_BLOCK request,
        determine by the erasure encoding type that there is sufficient
        projection blocks present to decode the data block, or ROLLBACK_BLOCK
        the existing projection blocks to back out the change.
      </t>

      <figure anchor='example_READ_BLOCK_COMMIT_args_1'>
        <artwork>
                Data Server 4
        +--------------------------------+
        | READ_BLOCK_COMMIT4args         |
        +--------------------------------+
        | rbca_stateid: 1ef3             |
        | rbca_offset: 4kB               |
        | rbca_count: 3                  |
        +----------+---------------------+
        </artwork>
      </figure>

      <t>
        <cref anchor="AI8" source="TH">Fix the stateid here and above</cref>
      </t>

      <t>
        <cref anchor="AI9" source="TH">Are the count bytes or number of blocks?</cref>
      </t>

      <figure anchor='example_READ_BLOCK_COMMIT_res_2_b'>
        <artwork>

                Data Server 4
        +--------------------------------+
        | READ_BLOCK_COMMIT4resok        |
        +--------------------------------+
        | rbcr_eof: true                 |
        | rbcr_blocks[0]:                |
        +----------+---------------------+
        |          | bo_block_id: 1      |
        |          | bo_change_id: 2     |
        |          | bo_client_id: 6     |
        |          | bo_committed: true  |
        +----------+---------------------+
        </artwork>
      </figure>
    </section>

    <section anchor="racing_clients" numbered="true" removeInRFC="false" toc="default">
      <name>Racing Clients</name>
      <t>
        Assume that the client has written to 6 data servers with WRITE_BLOCKs
        as in <xref target='example_WRITE_BLOCK_args_2' />. But now it gets back
        the conflicting results in <xref target='example_WRITE_BLOCK_res_3_a' />
        and <xref target='example_WRITE_BLOCK_res_3_b' />. From this, it can
        detect that there was a race with another client. Note, even though
        both clients present the same bo_change_id, nothing can be inferred
        as to the ordering of the two transactions. In some cases, bo_client_id 10
        won the race and in some cases, bo_client_id 6 won the race.
      </t>

      <t>
        As a subsequent READ_BLOCK will produce garbage, the clients need
        to agree on how to fix this issue without any communication.
      </t>

      <t>
        <cref anchor="AI11" source="TH">What are our options here?</cref>
      </t>

      <figure anchor='example_WRITE_BLOCK_res_3_a'>
        <artwork>
                Data Server 1
        +--------------------------------+
        | WRITE_BLOCK4resok              |
        +--------------------------------+
        | wbr_count: 3                   |
        | wbr_committed: FILE_SYNC4      |
        | wbr_writeverf: f1234abc        |
        | wbr_owners[0]:                 |
        +----------+---------------------+
        |          | bo_block_id: 1      |
        |          | bo_change_id: 3     |
        |          | bo_client_id: 10    |
        |          | bo_committed: true  |
        +----------+---------------------+
        | wbr_owners[1]:                 |
        +----------+---------------------+
        |          | bo_block_id: 1      |
        |          | bo_change_id: 3     |
        |          | bo_client_id: 6     |
        |          | bo_committed: false |
        +----------+---------------------+
        | wbr_owners[2]:                 |
        +----------+---------------------+
        |          | bo_block_id: 3      |
        |          | bo_change_id: 3     |
        |          | bo_client_id: 6     |
        |          | bo_committed: true  |
        +----------+---------------------+
        </artwork>
      </figure>

      <figure anchor='example_WRITE_BLOCK_res_3_b'>
        <artwork>
                Data Server 2
        +--------------------------------+
        | WRITE_BLOCK4resok              |
        +--------------------------------+
        | wbr_count: 3                   |
        | wbr_committed: FILE_SYNC4      |
        | wbr_writeverf: f1234abc        |
        | wbr_owners[0]:                 |
        +----------+---------------------+
        |          | bo_block_id: 1      |
        |          | bo_change_id: 3     |
        |          | bo_client_id: 6     |
        |          | bo_committed: true  |
        +----------+---------------------+
        | wbr_owners[1]:                 |
        +----------+---------------------+
        |          | bo_block_id: 1      |
        |          | bo_change_id: 3     |
        |          | bo_client_id: 10    |
        |          | bo_committed: false |
        +----------+---------------------+
        | wbr_owners[2]:                 |
        +----------+---------------------+
        |          | bo_block_id: 3      |
        |          | bo_change_id: 3     |
        |          | bo_client_id: 6     |
        |          | bo_committed: true  |
        +----------+---------------------+
        </artwork>
      </figure>
    </section>
  </section>

  <section anchor="supporting" numbered="true" removeInRFC="false" toc="default">
    <name>New Infrastructure</name>

    <section anchor="errors" numbered="true" removeInRFC="false" toc="default">
      <name>Errors</name>
      <section anchor="NFS4ERR_BLOCK_NOT_ALIGNED" numbered="true" removeInRFC="false" toc="exclude">
        <name>Error 10097 - NFS4ERR_BLOCK_NOT_ALIGNED</name>
        <t>
          A block operation was not aligned to the file's block length.
        </t>
      </section>
      <section anchor="NFS4ERR_ERASURE_ENCODING_NOT_SUPPORTED" numbered="true" removeInRFC="false" toc="exclude">
        <name>Error 10098 - NFS4ERR_ERASURE_ENCODING_NOT_SUPPORTED</name>
        <t>
          The client requested a ffv2_encoding_type which the server does not support.
          <cref anchor="AI2" source="TH">Get this straight</cref>
        </t>
      </section>
    </section>

    <section anchor="attrs" numbered="true" removeInRFC="false" toc="default">
      <name>Attributes</name>
      <section anchor="attr_block_size" numbered="true" removeInRFC="false" toc="exclude">
        <name>fattr4_block_size</name>

        <figure anchor='code_fattr4_block_size'>
          <sourcecode type='xdr'>
///
/// typedef unit32_t      fattr4_block_size;
///
/// const FATTR4_BLOCK_SIZE            = 88;
///
          </sourcecode>
        </figure>

        <t>
          The block size for READ_BLOCK and WRITE_BLOCK operations. If not supplied
          by the server before a WRITE_BLOCK, it <bcp14>MUST</bcp14> become the
          block size of the first WRITE_BLOCK.
        </t>

        <t>
          <cref anchor="AI3" source="TH">How does the data server get this information?</cref>
        </t>
      </section>
    </section>

    <section anchor="block_owner" numbered="true" removeInRFC="false" toc="default">
      <name>Block Owner</name>

      <figure anchor='code_block_owner4'>
        <sourcecode type='xdr'>
/// struct block_owner4 {
///     uint32_t    bo_block_id;
///     changeid4   bo_change_id;
///     clientid4   bo_client_id;
///     bool        bo_committed;
/// };
        </sourcecode>
      </figure>

      <t>
        The block_owner4 (see <xref target='code_block_owner4' />)
        is used to determine when and by whom a block was written.
        The bo_block_id is used to identify the block and <bcp14>MUST</bcp14>
        be the index of the block within the file. I.e., it is the
        offset of the start of the block divided by the block len.
        The bo_client_id <bcp14>MUST</bcp14> be the client id handed out
        by the metadata server to the client as the eir_clientid during
        the EXCHANGE_ID results (see Section 18.35 of <xref target="RFC8881"
        format="default" sectionFormat="of" />)  and <bcp14>MUST NOT</bcp14>
        be the client id supplied by the data server to the client. I.e.,
        across all data files, the bo_client_id uniquely describes one and
        only one client.
      </t>
      <t>
        The bo_change_id is like the change attribute
        (see Section 5.8.1.4 of <xref target="RFC8881" format="default"
        sectionFormat="of" />) in that each block write by a given
        client has to have an unique bo_change_id. I.e., it can
        be determined which transaction across all data files that
        a block corresponds.
      </t>
      <t>
        The bo_committed is used by the data server to indicate whether
        the block I/O was committed or not. The first WRITE_BLOCK to
        a location is automatically committed. Subsequent WRITE_BLOCK modifications
        to that block location are not automatically committed. The
        client has to COMMIT_BLOCK the block in order to get it committed.
      </t>
    </section>
  </section>

  <section anchor="ops" numbered="true" removeInRFC="false" toc="default">
    <name>New NFSv4.2 Operations</name>
    <section anchor="COMMIT_BLOCK" numbered="true" removeInRFC="false" toc="default">
      <name>Operation 77: COMMIT_BLOCK - Commit Cached Block Data</name>
      <section anchor="COMMIT_BLOCK_args" numbered="true" removeInRFC="false" toc="exclude">
        <name>ARGUMENTS</name>
        <figure anchor='code_COMMIT_BLOCK4args'>
          <sourcecode type='xdr'>
/// struct COMMIT_BLOCK4args {
///     /* CURRENT_FH: file */
///     offset4         cba_offset;
///     count4          cba_count;
///     block_owner4    cba_blocks&lt;&gt;;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor="COMMIT_BLOCK_res" numbered="true" removeInRFC="false" toc="exclude">
        <name>RESULTS</name>
        <figure anchor='code_COMMIT_BLOCK4resok'>
          <sourcecode type='xdr'>
/// struct COMMIT_BLOCK4resok {
///     verifier4       cbr_writeverf;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_COMMIT_BLOCK4res'>
          <sourcecode type='xdr'>
/// union COMMIT_BLOCK4res switch (nfsstat4 cbr_status) {
///     case NFS4_OK:
///         COMMIT_BLOCK4resok   cbr_resok4;
///     default:
///         void;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor="COMMIT_BLOCK_desc" numbered="true" removeInRFC="false" toc="exclude">
        <name>DESCRIPTION</name>
        <t>
          COMMIT_BLOCK is COMMIT (see Section 18.3 of <xref target="RFC8881"
          format="default" sectionFormat="of" />) with additional semantics
          over the block_owner the committing of blocks. As such, all of
          the normal semantics of COMMIT directly apply.
        </t>
      </section>
    </section>

    <section anchor="READ_BLOCK_COMMIT" numbered="true" removeInRFC="false" toc="default">
      <name>Operation 78: READ_BLOCK_COMMIT - Read Block Commit Status from File</name>
      <section anchor="READ_BLOCK_COMMIT_args" numbered="true" removeInRFC="false" toc="exclude">
        <name>ARGUMENTS</name>
        <figure anchor='code_READ_BLOCK_COMMIT4args'>
          <sourcecode type='xdr'>
/// struct READ_BLOCK_COMMIT4args {
///     /* CURRENT_FH: file */
///     stateid4    rbca_stateid;
///     offset4     rbca_offset;
///     count4      rbca_count;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor="READ_BLOCK_COMMIT_res" numbered="true" removeInRFC="false" toc="exclude">
        <name>RESULTS</name>
        <figure anchor='code_READ_BLOCK_COMMIT4resok'>
          <sourcecode type='xdr'>
/// struct READ_BLOCK_COMMIT4resok {
///     bool            rbcr_eof;
///     block_owner4    rbcr_blocks&lt;&gt;;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_READ_BLOCK_COMMIT4res'>
          <sourcecode type='xdr'>
/// union READ_BLOCK_COMMIT4res switch (nfsstat4 rbcr_status) {
///     case NFS4_OK:
///         READ_BLOCK4resok     rbcr_resok4;
///     default:
///         void;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor="READ_BLOCK_COMMIT_desc" numbered="true" removeInRFC="false" toc="exclude">
        <name>DESCRIPTION</name>
        <t>
          READ_BLOCK_COMMIT differs from READ_BLOCK in that it only reads
          committed and uncommitted projection headers in the desired data range.
        </t>
      </section>
    </section>

    <section anchor="READ_BLOCK" numbered="true" removeInRFC="false" toc="default">
      <name>Operation 79: READ_BLOCK - Read Blocks from File</name>
      <section anchor="READ_BLOCK_args" numbered="true" removeInRFC="false" toc="exclude">
        <name>ARGUMENTS</name>
        <figure anchor='code_READ_BLOCK4args'>
          <sourcecode type='xdr'>
/// struct READ_BLOCK4args {
///     /* CURRENT_FH: file */
///     stateid4    rba_stateid;
///     offset4     rba_offset;
///     count4      rba_count;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor="READ_BLOCK_res" numbered="true" removeInRFC="false" toc="exclude">
        <name>RESULTS</name>

        <figure anchor='code_read_block4'>
          <sourcecode type='xdr'>
/// struct read_block4 {
///     uint32_t        rb_crc;
///     block_owner4    rb_owner;
///     opaque          rb_block&lt;&gt;;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_READ_BLOCK4resok'>
          <sourcecode type='xdr'>
/// struct READ_BLOCK4resok {
///     bool        rbr_eof;
///     read_block4 rbr_blocks&lt;&gt;;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_READ_BLOCK4res'>
          <sourcecode type='xdr'>
/// union READ_BLOCK4res switch (nfsstat4 rbr_status) {
///     case NFS4_OK:
///          READ_BLOCK4resok     rbr_resok4;
///     default:
///          void;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor="READ_BLOCK_desc" numbered="true" removeInRFC="false" toc="exclude">
        <name>DESCRIPTION</name>
        <t>
          READ_BLOCK is READ (see Section 18.22 of <xref target="RFC8881"
          format="default" sectionFormat="of" />) with additional semantics
          over the block_owner and the committing of blocks. As such, all of
          the normal semantics of READ directly apply.
        </t>
        <t>
          The main area of difference is that READ_BLOCK works with blocks
          of data and not raw data streams. As such rba_offset
          <bcp14>MUST</bcp14> be a multiple of the block size. I.e., the
          reads <bcp14>MUST</bcp14> be aligned and <bcp14>MUST NOT</bcp14>
          overlap as that would cause corruption. When the server
          processes a READ_BLOCK, it <bcp14>MUST</bcp14> return an
          error of NFS4ERR_BLOCK_NOT_ALIGNED if the first block to be
          written would cause data corruption.
        </t>
        <t>
          READ_BLOCK also only returns the committed block at the location.
          <cref anchor="AI6" source="TH">Expand on this...</cref>
        </t>
        <t>
          <cref anchor="AI4" source="TH">Describe what happens on reading an incomplete data block.</cref>
        </t>
        <t>
          <cref anchor="AI5" source="TH">Describe what happens on reading a data block which was never written.</cref>
        </t>
      </section>
    </section>

    <section anchor="ROLLBACK_BLOCK" numbered="true" removeInRFC="false" toc="default">
      <name>Operation 80: ROLLBACK_BLOCK - Rollback Cached Block Data</name>
      <section anchor="ROLLBACK_BLOCK_args" numbered="true" removeInRFC="false" toc="exclude">
        <name>ARGUMENTS</name>
        <figure anchor='code_ROLLBACK_BLOCK4args'>
          <sourcecode type='xdr'>
/// struct ROLLBACK_BLOCK4args {
///     /* CURRENT_FH: file */
///     offset4         rba_offset;
///     count4          rba_count;
///     block_owner4    rba_blocks&lt;&gt;;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor="ROLLBACK_BLOCK_res" numbered="true" removeInRFC="false" toc="exclude">
        <name>RESULTS</name>
        <figure anchor='code_ROLLBACK_BLOCK4resok'>
          <sourcecode type='xdr'>
/// struct ROLLBACK_BLOCK4resok {
///     verifier4       rbr_writeverf;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_ROLLBACK_BLOCK4res'>
          <sourcecode type='xdr'>
/// union ROLLBACK_BLOCK4res switch (nfsstat4 rbr_status) {
///     case NFS4_OK:
///         ROLLBACK_BLOCK4resok   rbr_resok4;
///     default:
///         void;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor="ROLLBACK_BLOCK_desc" numbered="true" removeInRFC="false" toc="exclude">
        <name>DESCRIPTION</name>
        <t>
          ROLLBACK_BLOCK is a new form like COMMIT (see Section 18.3 of <xref target="RFC8881"
          format="default" sectionFormat="of" />) with additional semantics
          over the block_owner the rolling back the writing of blocks. As such, all of
          the normal semantics of COMMIT directly apply.
        </t>

        <t>
          ROLLBACK_BLOCK uncommits prior WRITE_BLOCK transactions. In case of write
          holes, it allows the client to undo transactions to repair the file.
        </t>
      </section>
    </section>

    <section anchor="WRITE_BLOCK" numbered="true" removeInRFC="false" toc="default">
      <name>Operation 81: WRITE_BLOCK - Write Blocks to File</name>
      <section anchor="WRITE_BLOCK_args" numbered="true" removeInRFC="false" toc="exclude">
        <name>ARGUMENTS</name>
        <figure anchor='code_write_block4'>
          <sourcecode type='xdr'>
/// struct write_block4 {
///     uint32_t        wb_crc;
///     opaque          wb_block&lt;&gt;;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_WRITE_BLOCK4args'>
          <sourcecode type='xdr'>
/// struct WRITE_BLOCK4args {
///     /* CURRENT_FH: file */
///     stateid4        wba_stateid;
///     offset4         wba_offset;
///     stable_how4     wba_stable;
///     block_owner4    wba_owner;
///     uint32_t        wba_id;
///     write_block4    wba_data&lt;&gt;;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor="WRITE_BLOCK_res" numbered="true" removeInRFC="false" toc="exclude">
        <name>RESULTS</name>

        <figure anchor='code_WRITE_BLOCK4resok'>
          <sourcecode type='xdr'>
/// struct WRITE_BLOCK4resok {
///     count4          wbr_count;
///     stable_how4     wbr_committed;
///     verifier4       wbr_writeverf;
///     block_owner4    wbr_owners&lt;&gt;;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_WRITE_BLOCK4res'>
          <sourcecode type='xdr'>
/// union WRITE_BLOCK4res switch (nfsstat4 wbr_status) {
///     case NFS4_OK:
///         WRITE_BLOCK4resok    wbr_resok4;
///     default:
///         void;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor="WRITE_BLOCK_desc" numbered="true" removeInRFC="false" toc="exclude">
        <name>DESCRIPTION</name>
        <t>
          WRITE_BLOCK is WRITE (see Section 18.32 of <xref target="RFC8881"
          format="default" sectionFormat="of" />) with additional semantics
          over the block_owner and the committing of blocks. As such, all of
          the normal semantics of WRITE directly apply.
        </t>
        <t>
          The main difference between the two operations is that WRITE_BLOCK
          works on blocks and not a raw data stream. As such wba_offset
          <bcp14>MUST</bcp14> be a multiple of the block size. I.e., the
          writes <bcp14>MUST</bcp14> be aligned and <bcp14>MUST NOT</bcp14>
          overlap as that would cause corruption. When the server
          processes a WRITE_BLOCK, it <bcp14>MUST</bcp14> return an
          error of NFS4ERR_BLOCK_NOT_ALIGNED if the first block to be
          written would cause data corruption.
        </t>
        <t>
          <cref anchor="AI3" source="TH">Need to have a new attribute for block size</cref>
        </t>
      </section>
    </section>
 </section>

  <section anchor="xdr_desc" numbered="true" removeInRFC="false" toc="default">
    <name>Extraction of XDR</name>
    <t>
      This document contains the external data representation (XDR)
      <xref target="RFC4506" format="default" sectionFormat="of"/> description of
      the flex files version 2 layout type.  The XDR description is embedded in this
      document in a way that makes it simple for the reader to extract
      into a ready-to-compile form.  The reader can feed this document
      into the following shell script to produce the machine readable
      XDR description of the new flags:
    </t>
    <sourcecode type='xdr'>
#!/bin/sh
grep '^ *///' $* | sed 's?^ */// ??' | sed 's?^ *///$??'
    </sourcecode>
    <t>
      That is, if the above script is stored in a file called "extract.sh", and
      this document is in a file called "spec.txt", then the reader can do:
    </t>
    <sourcecode type='xdr'>
sh extract.sh &lt; spec.txt &gt; erasure_coding_prot.x
    </sourcecode>
    <t>
      The effect of the script is to remove leading white space from each
      line, plus a sentinel sequence of "///".  XDR descriptions with the
      sentinel sequence are embedded throughout the document.
    </t>
    <t>
      Note that the XDR code contained in this document depends on types
      from the NFSv4.2 nfs4_prot.x file (generated from
      <xref target="RFC7863" format="default" sectionFormat="of"/>)
      and the Flex Files Layout Type flexfiles.x file (generated from
      <xref target="RFC8435" format="default" sectionFormat="of"/>).
      This includes both nfs types that end with a 4, such as offset4,
      length4, etc., as well as more generic types such as uint32_t and
      uint64_t.
    </t>
    <t>
      While the XDR can be appended to that from
      <xref target="RFC7863" format="default" sectionFormat="of"/>,
      the various code snippets belong in their respective areas of
      that XDR.
    </t>
  </section>

  <section anchor="sec_security" numbered="true" removeInRFC="false" toc="default">
    <name>Security Considerations</name>
    <t>
      This document has the same security considerations as both Flex Files
      Layout Type version 1 (see Section 15 of <xref target="RFC8435"
      format="default" sectionFormat="of" />) and NFSv4.2 (see Section 17 of <xref
      target="RFC7862" format="default" sectionFormat="of" />).
    </t>
  </section>

  <section anchor="sec_iana" numbered="true" removeInRFC="false" toc="default">
    <name>IANA Considerations</name>

    <section anchor="sec_iana_layouts" numbered="true" removeInRFC="false" toc="default">
      <name>pNFS Layout Types Registry</name>
      <t>
        <xref target="RFC8881" format="default" sectionFormat="of" />
        introduced the "pNFS Layout Types Registry"; new layout type
        numbers in this registry need to be assigned by IANA.  This document
        defines the protocol associated with an existing layout type number:
        LAYOUT4_FLEX_FILES_V2 (see <xref target='layoutlist' />).
      </t>

      <table anchor="layoutlist">
        <name>Layout Type Assignments</name>
        <thead>
          <tr>
            <th>Layout Type Name</th>
            <th>Value</th>
            <th>RFC</th>
            <th>How</th>
            <th>Minor Versions</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>LAYOUT4_FLEX_FILES_V2</td> <td>0x6</td> <td>RFCTBD10</td> <td>L</td> <td>1</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section anchor="sec_iana_recallable" numbered="true" removeInRFC="false" toc="default">
      <name>NFSv4 Recallable Object Types Registry</name>
      <t>
        <xref target="RFC8881" format="default" sectionFormat="of" /> also
        introduced the "NFSv4 Recallable Object Types Registry".  This document
        defines new recallable objects for RCA4_TYPE_MASK_FF2_LAYOUT_MIN and
        RCA4_TYPE_MASK_FF2_LAYOUT_MAX (see <xref target='recalllist' />).
      </t>

      <table anchor="recalllist">
        <name>Recallable Object Type Assignments</name>
        <thead>
          <tr>
            <th>Recallable Object Type Name</th>
            <th>Value</th>
            <th>RFC</th>
            <th>How</th>
            <th>Minor Versions</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>RCA4_TYPE_MASK_FF2_LAYOUT_MIN</td> <td>20</td> <td>RFCTBD10</td> <td>L</td> <td>1</td>
          </tr>
          <tr>
            <td>RCA4_TYPE_MASK_FF2_LAYOUT_MAX</td> <td>21</td> <td>RFCTBD10</td> <td>L</td> <td>1</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section anchor="sec_iana_encoding" numbered="true" removeInRFC="false" toc="default">
      <name>Flex Files V2 Erasure Encoding Type Registry</name>
      <t>
        This document introduces the "Flex Files V2 Erasure Encoding Type Registry". This
        document defines the FF2_ENCODING_TYPE_MIRRORED type for Client-Side Mirroring
        (see <xref target='erasure_encoding' />).
      </t>

      <table anchor="erasure_encoding">
        <name>Flex Files V2 Erasure Encoding Type Assignments</name>
        <thead>
          <tr>
            <th>Erasure Encoding Type Name</th>
            <th>Value</th>
            <th>RFC</th>
            <th>How</th>
            <th>Minor Versions</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>FF2_ENCODING_TYPE_MIRRORED</td> <td>1</td> <td>RFCTBD10</td> <td>L</td> <td>1</td>
          </tr>
        </tbody>
      </table>
    </section>
  </section>

</middle>

<back>

<references>
  <name>References</name>

  <references>
  <name>Normative References</name>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4506.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7530.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7862.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7863.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8178.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8435.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8881.xml"/>
  </references>

  <references>
  <name>Informative References</name>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1813.xml"/>
  </references>
</references>

<section numbered="true" removeInRFC="false" toc="default">
  <name>Acknowledgments</name>
  <t>
    The following from Hammerspace were instrumental in driving
    Flex Files v2: David Flynn, Trond Myklebust, Tom Haynes, Didier Feron,
    Jean-Pierre Monchanin, Pierre Evenou, and Brian Pawlowski.
  </t>
  <t>
    Christoph Helwig was instrumental in making sure Flex Files v2
    was applicable to more than one Erasure-Encoding Type.
  </t>
</section>

<section numbered="true" removeInRFC="true" toc="default">
  <name>RFC Editor Notes</name>

  <t>
    [RFC Editor: prior to publishing this document as an RFC, please
    replace all occurrences of RFCTBD10 with RFCxxxx where xxxx is the
    RFC number of this document]
  </t>
</section>

</back>

</rfc>
