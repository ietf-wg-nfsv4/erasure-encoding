<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt'?>

<rfc
 category='std'
 docName='draft-haynes-nfsv4-erasure-encoding-VERSIONVAR'
 ipr='trust200902'
 obsoletes=''
 scripts='Common,Latin'
 sortRefs='true'
 submissionType='IETF'
 symRefs='true'
 tocDepth='3'
 tocInclude='true'
 version='3'
 consensus='true'
 xml:lang='en'>

<front>
  <title abbrev='erasure encoding'>
    Erasure Encoding of Files in NFSv4.2
  </title>
  <seriesInfo name='Internet-Draft' value='draft-haynes-nfsv4-erasure-encoding-VERSIONVAR'/>
  <author fullname='Thomas Haynes' initials='T.' surname='Haynes'>
    <organization abbrev='Hammerspace'>Hammerspace</organization>
    <address>
      <email>loghyr@gmail.com</email>
    </address>
  </author>
  <date year='YEARVAR' month='MONTHVAR' day='DAYVAR'/>
  <area>Transport</area>
  <workgroup>Network File System Version 4</workgroup>
  <keyword>NFSv4</keyword>
  <abstract>
    <t>
      Parallel NFS (pNFS) allows a separation between the metadata (onto
      a metadata server) and data (onto a storage device) for a file.
      The Flexible File Version 2 Layout Type is defined in this document
      as an extension to pNFS that allows the use of storage devices that
      require only a limited degree of interaction with the metadata
      server and use already-existing protocols.  Data replication is
      also added to provide integrity.
    </t>
  </abstract>

  <note removeInRFC='true'>
    <t>
      Discussion of this draft takes place
      on the NFSv4 working group mailing list (nfsv4@ietf.org),
      which is archived at
      <eref target='https://mailarchive.ietf.org/arch/browse/nfsv4/'/>.
      Working Group information can be found at
      <eref target='https://datatracker.ietf.org/wg/nfsv4/about/'/>.
    </t>
  </note>

  <note removeInRFC='true'>
    <t>
      This draft starts sparse and will be filled in as details are
      ironed out.
      In the first draft, we simply explain the
      semantics changes. As these are accepted by the knowledgeable reviewers,
      we will flesh out the operation description sections to include sub-sections more
      akin to 18.32.3 and 18.32.4 of <xref target='RFC8881' />.
    </t>
    <t>
      Except where called out, all the semantics of the Flexible File Version 1 Layout
      Type presented in <xref target='RFC8435' /> still apply. This new
      version extends it and does not replace it.
    </t>
  </note>
</front>

<middle>

  <section anchor='sec_intro' numbered='true' removeInRFC='false' toc='default'>
    <name>Introduction</name>
    <t>
      In Parallel NFS (pNFS) (see Section 12 of
      <xref target='RFC8881' />),
      the metadata server returns layout type
      structures that describe where file data is located.  There are
      different layout types for different storage systems and methods
      of arranging data on storage devices.  <xref target='RFC8435' />
      defined the Flexible
      File Version 1 Layout Type used with file-based data servers that are
      accessed using the NFS protocols: NFSv3 <xref target='RFC1813' />,
      NFSv4.0 <xref target='RFC7530' />, NFSv4.1 <xref target='RFC8881' />, and
      NFSv4.2 <xref target='RFC7862' />.
    </t>

    <t>
      The Client Side Mirroring (see Section 8 of <xref target='RFC8435' />), introduced with the first
      version of the Flexible File Layout Type, provides for replication
      of data but does not provide for integrity of data. In the event
      of an error, an user would be able to repair the file by silvering
      the mirror contents. I.e., they would pick one of the mirror
      instances and replicate it to the other instance locations.
    </t>

    <t>
      However, lacking integrity checks, silent corruptions are not able
      to be detected and the choice of what constitutes the good copy
      is difficult.  This document updates the Flexible File Layout Type
      to version 2 by providing data integrity for erasure encoding.
      It introduces a new operation RESERVE that allow the client to reserve
      ranges of the data file by creating a reservation file to store
      modifications. When the client is ready, it will use RESERVE_SWAP
      to atomically exchange the blocks in the reservation file with
      those in the data file. Finally, it will use RESERVE_RELEASE
      to start the deletion of old blocks. Both RESERVE_RECOVER
      and ROLLBACK_LIST can be used by the client or metadata server
      to recover after a client restart or a client which has
      permanently gone away.
    </t>

    <t>
      Using the process detailed in <xref target='RFC8178' format='default'
      sectionFormat='of'/>, the revisions in this document become an
      extension of NFSv4.2 <xref target='RFC7862' format='default'
      sectionFormat='of'/>. They are built on top of the external data
      representation (XDR) <xref target='RFC4506' format='default'
      sectionFormat='of'/> generated from <xref target='RFC7863' />.
    </t>

    <section anchor='sec_defs' numbered='true' removeInRFC='false' toc='default'>
      <name>Definitions</name>
      <dl newline='false' spacing='normal'>
        <dt>chunk:</dt>
        <dd>
          One of the resulting chunks to be exchanged with a data
          server after a transformation has been applied to
          a data block. The resulting chunk
          may be a different size than the data block.
        </dd>

        <dt>Client Side Mirroring:</dt>
        <dd>
          A file based replication method where copies are maintained
          in parallel.
        </dd>

        <dt>data block:</dt>
        <dd>
          A block of data in the client's cache for a file.
        </dd>

        <dt>data file:</dt>
        <dd>
          The data portion of the file, stored on the data server.
        </dd>

        <dt>Erasure Encoding:</dt>
        <dd>
          A data protection scheme where a block of data is replicated
          into fragments and additional redundant fragments are added
          to achieve parity. The new chunks are stored in different
          locations.
        </dd>

        <dt>Client Side Erasure Encoding:</dt>
        <dd>
          A file based integrity method where copies are maintained
          in parallel.
        </dd>

        <dt>integrity of data:</dt>
        <dd>
          Data integrity refers to the accuracy, consistency, and
          reliability of data throughout its life cycle.
        </dd>

        <dt>metadata file:</dt>
        <dd>
          The metadata portion of the file, stored on the metadata server.
        </dd>

        <dt>reservation file:</dt>
        <dd>
          A temporary file established when a reservation is created.
          It contains modifications which are intended to be swapped
          with the orginal file.
        </dd>

        <dt>replication of data:</dt>
        <dd>
          Data replication is making and storing multiple copies
          of data in different locations.
        </dd>

        <dt>write hole:</dt>
        <dd>
          A write hole is a data corruption scenario where either
          two clients are trying to write to the same chunk or
          one client is overwriting an existing chunk of data.
        </dd>
      </dl>
    </section>

    <section numbered='true' removeInRFC='false' toc='default'>
      <name>Requirements Language</name>
      <t>
        The key words '<bcp14>MUST</bcp14>', '<bcp14>MUST NOT</bcp14>',
        '<bcp14>REQUIRED</bcp14>', '<bcp14>SHALL</bcp14>', '<bcp14>SHALL
        NOT</bcp14>', '<bcp14>SHOULD</bcp14>', '<bcp14>SHOULD NOT</bcp14>',
        '<bcp14>RECOMMENDED</bcp14>', '<bcp14>NOT RECOMMENDED</bcp14>',
        '<bcp14>MAY</bcp14>', and '<bcp14>OPTIONAL</bcp14>' in this
        document are to be interpreted as described in BCP 14 <xref
        target='RFC2119' /> <xref target='RFC8174' /> when,
        and only when, they appear in all capitals, as shown here.
      </t>
    </section>
  </section>

  <section numbered='true' removeInRFC='false' toc='default'>
    <name>Flexible File Version 2 Layout Type</name>
    <t>
      In order to introduce erasure encoding to pNFS, a new layout type
      of LAYOUT4_FLEX_FILES_V2 needs to be defined.  While we could
      define a new layout type per erasure encoding type, there exist
      use cases where multiple erasure encoding types exist in the same layout.
    </t>
    <t>
      The original layouttype4 introduced in <xref target='RFC8881' />
      is modified to as in <xref target='code_layout4' />.
    </t>

    <figure anchor='code_layout4'>
      <sourcecode type='xdr'>
       enum layouttype4 {
           LAYOUT4_NFSV4_1_FILES   = 1,
           LAYOUT4_OSD2_OBJECTS    = 2,
           LAYOUT4_BLOCK_VOLUME    = 3,
           LAYOUT4_FLEX_FILES      = 4,
           LAYOUT4_FLEX_FILES_V2   = 5
       };

       struct layout_content4 {
           layouttype4             loc_type;
           opaque                  loc_body&lt;&gt;;
       };

       struct layout4 {
           offset4                 lo_offset;
           length4                 lo_length;
           layoutiomode4           lo_iomode;
           layout_content4         lo_content;
       };
      </sourcecode>
    </figure>

    <t>
      This document defines structures associated with the layouttype4
      value LAYOUT4_FLEX_FILES_V2.  <xref target='RFC8881' format='default'
      sectionFormat='of' /> specifies the loc_body structure as an XDR
      type 'opaque'.  The opaque layout is uninterpreted by the generic
      pNFS client layers but is interpreted by the Flexible File Version 2 Layout
      Type implementation.  This section defines the structure of this
      otherwise opaque value, ffv2_layout4.
    </t>

    <section anchor='ffv2_encoding_type4' numbered='true' removeInRFC='false' toc='default'>
      <name>ffv2_encoding_type4</name>

      <figure anchor='code_ffv2_encoding_type4'>
        <sourcecode type='xdr'>
   /// enum ffv2_encoding_type4 {
   ///     FFV2_ENCODING_MIRRORED       = 0x1;
   /// };
        </sourcecode>
      </figure>

      <t>
        The ffv2_encoding_type4 (see <xref target='code_ffv2_encoding_type4' />)
        encompasses a new IANA registry for 'Flex Files V2 Erasure
        Encoding Type Registry' (see <xref target='sec_iana_encoding' />).
        I.e., instead of defining a new Layout Type for each
        Erasure Encoding, we define a new Erasure Encoding Type.
        Except for FFV2_ENCODING_MIRRORED, each of the types
        is expected to employ the new operations in this document.
      </t>

      <t>
        FFV2_ENCODING_MIRRORED offers replication of data and
        not integrity of data. As such, it does not need operations
        like CHUNK_WRITE (see <xref target='CHUNK_WRITE' />).
      </t>
    </section>

    <section anchor='ss_write_mirror' numbered='true' removeInRFC='false' toc='default'>
      <name>To be done later</name>
    </section>

    <section anchor='ffv2_flags4' numbered='true' removeInRFC='false' toc='default'>
      <name>ffv2_flags4</name>
      <figure anchor='code_ffv2_flags4'>
        <sourcecode type='xdr'>
/// const FFV2_FLAGS_NO_LAYOUTCOMMIT   = 0x00000001;
/// const FFV2_FLAGS_NO_IO_THRU_MDS    = 0x00000002;
/// const FFV2_FLAGS_NO_READ_IO        = 0x00000004;
/// const FFV2_FLAGS_WRITE_ONE_MIRROR  = 0x00000008;
/// const FFV2_FLAGS_ONLY_ONE_WRITER   = 0x00000010;
/// typedef uint32_t ffv2_flags4;
        </sourcecode>
      </figure>

      <t>
        The ff2_flags4 in <xref target='code_ffv2_flags4' /> is a bitmap
        that allows the metadata server to inform
        the client of particular conditions that may result from more or
        less tight coupling of the storage devices.
      </t>

      <dl newline='false' spacing='normal'>
        <dt>FFV2_FLAGS_NO_LAYOUTCOMMIT:</dt>
        <dd>
           can be set to indicate that the client is not required to
           send LAYOUTCOMMIT to the metadata server.
        </dd>

        <dt>FFV2_FLAGS_NO_IO_THRU_MDS:</dt>
        <dd>
           can be set to indicate that the client should not send I/O
           operations to the metadata server.  That is, even if the
           client could determine that there was a network disconnect
           to a storage device, the client should not try to proxy the
           I/O through the metadata server.
        </dd>

        <dt>FFV2_FLAGS_NO_READ_IO:</dt>
        <dd>
           can be set to indicate that the client should not send READ
           requests with the layouts of iomode LAYOUTIOMODE4_RW.  Instead,
           it should request a layout of iomode LAYOUTIOMODE4_READ from
           the metadata server.
        </dd>

        <dt>FFV2_FLAGS_WRITE_ONE_MIRROR:</dt>
        <dd>
           can be set to indicate that the client only needs to update
           one of the mirrors (see <xref target='ss_write_mirror' />).
        </dd>

        <dt>FFV2_FLAGS_ONLY_ONE_WRITER:</dt>
        <dd>
          can be set to indicate that the client only needs to use
          CHUNK_WRITE_SWAP to update the chunks in the data file. I.e.,
          keep the ability to rollback in case of a write hole
          caused by overwriting. If this flag is not set, then the
          client <bcp14>MUST</bcp14> write chunks with CHUNK_WRITE_SWAP_GUARD
          in order to prevent collision across the data servers.
        </dd>
      </dl>
    </section>

    <section anchor='ffv2_file_info4' numbered='true' removeInRFC='false' toc='default'>
      <name>ffv2_file_info4</name>
      <figure anchor='code_ffv2_file_info4'>
        <sourcecode type='xdr'>
   /// struct ffv2_file_info4 {
   ///     stateid4                fffi_stateid;
   ///     nfs_fh4                 fffi_fh_vers;
   /// };
        </sourcecode>
      </figure>
      <t>
        The ffv2_file_info4 is a new structure to help with
        the stateid issue discussed in Section 5.1
        of <xref target='RFC8435' />. I.e., in
        version 1 of the Flexible File Layout Type, there
        was the singleton ffds_stateid combined with the
        ffds_fh_vers array. I.e., each NFSv4 version has
        its own stateid. In <xref target='code_ffv2_file_info4' />,
        each NFSv4 filehandle has a one-to-one correspondence to a stateid.
      </t>
    </section>

    <section anchor='ffv2_ds_flags4' numbered='true' removeInRFC='false' toc='default'>
      <name>ffv2_ds_flags4</name>
      <figure anchor='code_ffv2_ds_flags4'>
        <sourcecode type='xdr'>
   /// const FFV2_DS_FLAGS_ACTIVE        = 0x00000001;
   /// const FFV2_DS_FLAGS_SPARE         = 0x00000002;
   /// const FFV2_DS_FLAGS_PARITY        = 0x00000004;
   /// const FFV2_DS_FLAGS_REPAIR        = 0x00000008;
   /// typedef uint32_t            ffv2_ds_flags4;
        </sourcecode>
      </figure>
      <t>
        The ffv2_ds_flags4 (in <xref target='code_ffv2_ds_flags4' />) flags details
        the state of the data servers. With Erasure Encoding algorithms, there are both Systematic and Non-Systematic
        approaches. In the Systematic, the bits for integrity are placed amoungst the
        resulting transformed chunk. Such an implementation would typically see
        FFV2_DS_FLAGS_ACTIVE and FFV2_DS_FLAGS_SPARE data servers. The FFV2_DS_FLAGS_SPARE
        ones allow the client to repair a payload without enaging the metadata server.
        I.e., if one of the FFV2_DS_FLAGS_ACTIVE did not respond to a WRITE_BLOCK,
        the client could fail the chunk to the FFV2_DS_FLAGS_SPARE data server.
      </t>
      <t>
        With the Non-Systematic approach, the data and integrity live on different
        data servers. Such an implementation would typically see FFV2_DS_FLAGS_ACTIVE
        and FFV2_DS_FLAGS_PARITY data servers. If the implementation wanted to allow
        for local repair, it would also use FFV2_DS_FLAGS_SPARE.
      </t>
      <t>
        The FFV2_DS_FLAGS_REPAIR flag can be
        used by the metadata server to inform the client that the indicated
        data server is a replacement data server as far as existing data is
        concerned. The client <bcp14>MUST</bcp14> repair the file by using
        RESERVE on the entire length of the file and both decoding the existing
        data from the file and recoding the new data on the indicated data
        server. Whilst all data servers <bcp14>MUST</bcp14> be reserved,
        only the data server(s) to be repaired <bcp14>MUST</bcp14> have the RESERVE_SWAP
        operation applied. The remaining data servers can have their reservation
        files dropped via RESERVE_RELEASE.
      </t>
      <t>
        See  <xref target='Plank97' /> for further
        reference to storage layouts for encoding.
      </t>
    </section>

    <section anchor='ffv2_data_server4' numbered='true' removeInRFC='false' toc='default'>
      <name>ffv2_data_server4</name>
      <figure anchor='code_ffv2_data_server4'>
        <sourcecode type='xdr'>
   /// struct ffv2_data_server4 {
   ///     deviceid4               ffds_deviceid;
   ///     uint32_t                ffds_efficiency;
   ///     ffv2_file_info4         ffds_file_info&lt;&gt;;
   ///     fattr4_owner            ffds_user;
   ///     fattr4_owner_group      ffds_group;
   ///     ffv2_ds_flags4          ffds_flags;
   /// };
        </sourcecode>
      </figure>
      <t>
        The ffv2_data_server4 (in <xref target='code_ffv2_data_server4' />) describes
        a data file and how to access it via the different NFS protocols.
      </t>
    </section>

    <section anchor='ffv2_encoding_type_data4' numbered='true' removeInRFC='false' toc='default'>
      <name>ffv2_encoding_type_data4</name>
      <figure anchor='code_ffv2_encoding_type_data4'>
        <sourcecode type='xdr'>
   /// union ffv2_encoding_type_data4 switch
   ///         (ffv2_encoding_type4 fetd_encoding) {
   ///     case FFV2_ENCODING_MIRRORED:
   ///         void;
   /// };
        </sourcecode>
      </figure>
      <t>
        The ffv2_encoding_type_data4 (in <xref target='code_ffv2_encoding_type_data4' />) describes
        erasure encoding type specific fields. I.e., this is how the encoding type can
        communicate the need for counts of active, spare, parity, and repair types
        of chunks.
      </t>
    </section>

    <section anchor='ffv2_key4' numbered='true' removeInRFC='false' toc='default'>
      <name>ffv2_key4</name>
      <figure anchor='code_ffv2_key4'>
        <sourcecode type='xdr'>
   /// typedef opaque ffv2_key4&lt;&gt;;
        </sourcecode>
      </figure>
      <t>
        The ffv2_key4 (in <xref target='code_ffv2_key4' />) is a secret key known
        only to the metadata server, data server, and client. In the event of
        either a data server restart or a dead client, it can be used to
        restablish a connection via RESERVE_RECOVER.
      </t>
    </section>

    <section anchor='ffv2_mirror4' numbered='true' removeInRFC='false' toc='default'>
      <name>ffv2_mirror4</name>
      <figure anchor='code_ffv2_mirror4'>
        <sourcecode type='xdr'>
   /// struct ffv2_mirror4 {
   ///     ffv2_encoding_type_data4 ffm_encoding_type_data;
   ///     ffv2_key4                ffm_key;
   ///     uint32_t                 ffm_client_id;
   ///     ffv2_data_server4        ffm_data_servers&lt;&gt;;
   /// };
        </sourcecode>
      </figure>
      <t>
        The ffv2_mirror4 (in <xref target='code_ffv2_mirror4' />) describes
        the Flexible File Layout Version 2 specific fields. The ffm_key allows
        the client to access an already existing client file on the data servers
        and the ffm_client_id tells the client which id to use when interacting
        with the data servers.
      </t>
    </section>

    <section anchor='ffv2_layout4' numbered='true' removeInRFC='false' toc='default'>
      <name>ffv2_layout4</name>
      <figure anchor='code_ffv2_layout4'>
        <sourcecode type='xdr'>
   /// struct ffv2_layout4 {
   ///     length4                 ffl_stripe_unit;
   ///     ffv2_mirror4            ffl_mirrors&lt;&gt;;
   ///     ffv2_flags4             ffl_flags;
   ///     uint32_t                ffl_stats_collect_hint;
   /// };
        </sourcecode>
      </figure>
      <t>
        The ffv2_layout4 (in <xref target='code_ffv2_layout4' />) describes
        the Flexible File Layout Version 2.
      </t>
    </section>

    <section anchor='ffv2_layouthint4' numbered='true' removeInRFC='false' toc='default'>
      <name>ffv2_layouthint4</name>
      <figure anchor='code_ffv2_layouthint4'>
        <sourcecode type='xdr'>
/// union ffv2_mirrors_hint switch (ffv2_encoding_type4 ffmh_type) {
///     case FFV2_ENCODING_MIRRORED:
///         void;
/// };
///
/// struct ffv2_layouthint4 {
///     ffv2_encoding_type4 fflh_supported_types&lt;&gt;;
///     ffv2_mirrors_hint fflh_mirrors_hint;
/// };
        </sourcecode>
      </figure>
      <t>
        The ffv2_layouthint4 (in <xref target='code_ffv2_layouthint4' />) describes
        the layout_hint (see Section 5.12.4 of <xref target='RFC8881' />)
        that the client can provide to the metadata server.
      </t>
    </section>

    <section anchor='sec_mix_types' numbered='true' removeInRFC='false' toc='default'>
      <name>Mixing of Encoding Types</name>
      <t>
        Multiple encoding types can be present
        in a Flexible File Version 2 Layout Type layout.  The ffv2_layout4 has an array
        of ffv2_mirror4, each of which has a ffv2_encoding_type4.
        The main reason to allow for this is to provide for either the
        assimilation of a non-erasure encoded file to an erasure
        encoded file or the exporting of an erasure encoded file to
        a non-erasure encoded file.
      </t>
      <t>
        Assume there is an additional ffv2_encoding_type4 of
        FFV2_ENCODING_REED_SOLOMON and it needs 8 active chunks.
        The user wants to actively assimilate a regular
        file. As such, a layout might be as represented in <xref
        target='mixed_layout' />.  As this is an assimilation, most of
        the data reads will be satisfied by READ (see Section 18.22 of
        <xref target='RFC8881' />)
        calls to index 0. However, as this is also an active file,
        there could also be CHUNK_READ (see <xref target='CHUNK_READ' />)
        calls to the other indexes.
      </t>

      <figure anchor='mixed_layout'>
        <name>Example of Mixed Encoding Types in a Layout</name>
        <artwork>
         +---------------------------------------------------+
         | ffv2_layout4:                                     |
         +---------------------------------------------------+
         |     ffl_mirrors[0]:                               |
         |         ffm_data_servers:                         |
         |             ffv2_data_server4[0]                  |
         |                 ffds_flags: 0                     |
         |         ffm_encoding: FFV2_ENCODING_MIRRORED      |
         +---------------------------------------------------+
         |     ffl_mirrors[1]:                               |
         |         ffm_data_servers:                         |
         |             ffv2_data_server4[0]                  |
         |                 ffds_flags: FFV2_DS_FLAGS_ACTIVE  |
         |             ffv2_data_server4[1]                  |
         |                 ffds_flags: FFV2_DS_FLAGS_ACTIVE  |
         |             ffv2_data_server4[2]                  |
         |                 ffds_flags: FFV2_DS_FLAGS_ACTIVE  |
         |             ffv2_data_server4[3]                  |
         |                 ffds_flags: FFV2_DS_FLAGS_ACTIVE  |
         |             ffv2_data_server4[4]                  |
         |                 ffds_flags: FFV2_DS_FLAGS_PARITY  |
         |             ffv2_data_server4[5]                  |
         |                 ffds_flags: FFV2_DS_FLAGS_PARITY  |
         |             ffv2_data_server4[6]                  |
         |                 ffds_flags: FFV2_DS_FLAGS_SPARE   |
         |             ffv2_data_server4[7]                  |
         |                 ffds_flags: FFV2_DS_FLAGS_SPARE   |
         |     ffm_encoding: FFV2_ENCODING_REED_SOLOMON      |
         +---------------------------------------------------+
        </artwork>
      </figure>
      <t>
        When performing I/O via a FFV2_ENCODING_MIRRORED encoding
        type, the non-transformed data will be used, Whereas with
        other encoding types, a metadata header and transformed block will
        be sent. Further, when reading data from the instance files,
        the client <bcp14>MUST</bcp14> be prepared to have one of the
        encoding types supply data and the other type not to supply
        data. I.e., the CHUNK_READ call to the data servers in mirror 1
        might return rlr_eof set to true
        (see <xref target='code_CHUNK_READ4resok' />),
        which indicates that there is
        no data, where the READ call to the data server in mirror 0 might
        return eof to be false, which indicates that there is data. The
        client <bcp14>MUST</bcp14> determine that there is in fact data.
      </t>
      <t>
        An example use case is the active assimilation of a file to ensure
        integrity. As the client is helping to translated the file to
        the new encoding scheme, it is actively modifying the file. As
        such, it might be sequentially reading the file in order to
        translate. The READ calls to mirror 0  would be returning data
        and the CHUNK_READ calls to mirror 1 would not be returning data. As
        the client overwrites the file, the WRITE call and WRITE_SWAP_CHUNK call would have data
        sent to all of the data servers. Finally, if the client reads
        back a section which had been modified earlier, both
        the READ and CHUNK_READ calls would return data.
      </t>
    </section>
  </section>

  <section anchor='sec_erasure_encoding' numbered='true' removeInRFC='false' toc='default'>
    <name>Erasure Encoding</name>
    <t>
      Erasure Encoding takes a data block and transforms it to a payload to
      send to the data servers (see <xref target='encoding_transformation' />). It
      generates a metadata header and transformed block per data server. The header is metadata
      information for the transformed block. From now on, the metadata is
      simply referred to as the header and the transformed block as the
      chunk. The payload of a data block is the set of generated headers and chunks
      for that data block.
    </t>
    <t>
      The guard is an unique identifier generated by the client to
      describe the current write transaction (see <xref target='chunk_guard4' />).
      The intent is to have an unique and non-opauqe value for comparison.
      The payload_id describes the position within the payload.  Finally,
      the crc32 is the 32 bit crc calculation of the header (with the
      crc32 field being 0) and the chunk. By combining the two parts of
      the payload, integrity is ensured for both the parts.
    </t>
    <t>
      While the data block might have a length of 4kB, that does not
      necessarily mean that the length of the chunk
      is 4kB. That length is determined by the erasure encoding type
      algorithm. For example, Reed Solomon might have 4kB
      chunks with the data integrity being compromised by
      parity chunks. Another example would be the Mojette Transformation,
      which might have 1kB chunk lengths.
    </t>
    <t>
      The payload contains redundancy which will allow
      the erasure encoding type algorithm to repair
      chunks in the payload as it is transformed back to a data block (see
      <xref target='decoding_transformation' />).
      A payload is consistent when all of the contained headers
      share the same guard. It has integrity when it is consistent
      and the combinations of headers and chunks all pass the crc32 checks.
    </t>
    <t>
      The erasure encoding algorithm itelf might not be sufficient
      to detect errors in the chunks. The crc32 checks will allow
      the data server to detect chunks with issues and then the
      erasure decoding algorithm can reconstruct the missing chunk.
    </t>

    <section anchor='sec_encoding_transformation' numbered='true' removeInRFC='false' toc='default'>
      <name>Encoding a Data Block</name>

      <figure anchor='encoding_transformation'>
        <name>Encoding a Data Block</name>
        <artwork>
                  +-------------+
                  | data block  |
                  +-------+-----+
                          |
                          |
    +---------------------+-------------------------------+
    |            Erasure Encoding (Transform Forward)     |
    +---+----------------------+---------------------+----+
        |                      |                     |
        |                      |                     |
    +---+------------+     +---+------------+     +--+-------------+
    | HEADER         | ... | HEADER         | ... | HEADER         |
    +----------------+     +----------------+     +----------------+
    | guard:         | ... | guard:         | ... | guard:         |
    |   change_id: 3 | ... |   change_id: 3 | ... |   change_id: 3 |
    |   client_id: 6 | ... |   client_id: 6 | ... |   client_id: 6 |
    | payload_id : 0 | ... | payload_id : M | ... | payload_id : 5 |
    | crc32   :      | ... | crc32   :      | ... | crc32   :      |
    +----------------+     +----------------+     +----------------+
    | CHUNK          | ... | CHUNK          | ... | CHUNK          |
    +----------------+     +----------------+     +----------------+
    | data: ....     | ... | data: ....     | ... | data: ....     |
    +----------------+     +----------------+     +----------------+
      Data Server 1          Data Server N          Data Server 6
        </artwork>
      </figure>

      <t>
        Each data block of the file resident in the client's cache of the
        file will be encoded into N different payloads to be
        sent to the data servers as shown in <xref target='encoding_transformation' />.
        As CHUNK_WRITE (see <xref target='CHUNK_WRITE' />) can encode
        multiple write_chunk4 into a single transaction, a more accurate
        description of a CHUNK_WRITE might be as in <xref target='example_CHUNK_WRITE_args_1' />.
      </t>

      <figure anchor='example_CHUNK_WRITE_args_1'>
        <name>Example of CHUNK_WRITE_args</name>
        <artwork>
        +------------------------------------+
        | CHUNK_WRITEargs                    |
        +------------------------------------+
        | cwa_stateid: 0                     |
        | cwa_offset: 1                      |
        | cwa_stable: FILE_SYNC4             |
        | cwa_payload_id: 0                  |
        | cwa_owner:                         |
        |            co_guard:               |
        |                cg_change_id: 3     |
        |                cg_client_id: 6     |
        | cwa_chunk[0]:                      |
        |            cw_crc    :  0x32ef89   |
        |            cw_chunk  :  ......     |
        | cwa_chunk[1]:                      |
        |            cw_crc    :  0x56fa89   |
        |            cw_chunk  :  ......     |
        | cwa_chunk[2]:                      |
        |            cw_crc    :  0x7693af   |
        |            cw_chunk  :  ......     |
        +------------------------------------+
        </artwork>
      </figure>

      <t>
        This describes a 3 block write of data from an offset of 1 block in the file.
        As each block shares the cwa_owner, it is only
        presented once. I.e., the data server will be able to construct the
        header for each cwa_chunk from the cwa_payload_id, cwa_owner,
        and cw_crc.
      </t>

      <t>
        Assuming that there were no issues, <xref target='example_CHUNK_WRITE_res_1' />
        illustrates the results. The payload sequence id is implicit in the CHUNK_WRITEargs.
      </t>

      <figure anchor='example_CHUNK_WRITE_res_1'>
        <name>Example of CHUNK_WRITE_res</name>
        <artwork>
        +-------------------------------+
        | CHUNK_WRITEresok              |
        +-------------------------------+
        | cwr_count: 3                  |
        | cwr_committed: FILE_SYNC4     |
        | cwr_writeverf: 0xf1234abc     |
        | cwr_owners[0]:                |
        |        co_chunk_id: 1         |
        |        co_guard:              |
        |            cg_change_id: 3    |
        |            cg_client_id: 6    |
        | cwr_owners[1]:                |
        |        co_chunk_id: 2         |
        |        co_guard:              |
        |            cg_change_id: 3    |
        |            cg_client_id: 6    |
        | cwr_owners[2]:                |
        |        co_chunk_id: 3         |
        |        co_guard:              |
        |            cg_change_id: 3    |
        |            cg_client_id: 6    |
        +-------------------------------+
        </artwork>
      </figure>

      <section anchor='calculating_crc' numbered='true' removeInRFC='false' toc='exclude'>
        <name>Calculating the CRC32</name>
        <figure anchor='crc_before_calc'>
          <name>CRC32 Before Calculation</name>
          <artwork>
        +---+----------------+
        | HEADER             |
        +--------------------+
        | guard:             |
        |   change_id: 7     |
        |   cleint_id: 6     |
        | payload_id : 0     |
        | crc32   : 0        |
        +--------------------+
        | CHUNK              |
        +--------------------+
        | data:  ....        |
        +--------------------+
             Data Server 1
          </artwork>
        </figure>

        <t>
          Assuming the header and payload as in <xref target='crc_before_calc' />,
          the crc32 needs to be calculated in order to fill in the cw_crc field. In this
          case, the crc32 is calculated over the 3 fields as shown in the
          header and the cw_chunk. In this example, it is calculated
          to be 0x21de8. The resulting CHUNK_WRITE is shown in <xref target='crc_after_calc' />.
        </t>

        <figure anchor='crc_after_calc'>
          <name>CRC32 After Calculation</name>
          <artwork>
        +-----------------------------------+
        | CHUNK_WRITEargs                   |
        +-----------------------------------+
        | cwa_stateid: 0                    |
        | cwa_offset: 1                     |
        | cwa_stable: FILE_SYNC4            |
        | cwa_payload_id: 0                 |
        | cwa_owner:                        |
        |        co_guard:                  |
        |          cg_change_id: 7          |
        |          cg_client_id: 6          |
        | cwa_chunk[0]:                     |
        |        cw_crc    :  0x21de8       |
        |        cw_chunk  :  ......        |
        +-----------------------------------+
          </artwork>
        </figure>
      </section>
    </section>

    <section anchor='sec_decoding_transformation' numbered='true' removeInRFC='false' toc='default'>
      <name>Decoding a Data Block</name>
      <figure anchor='decoding_transformation'>
        <name>Decoding a Data Block</name>
        <artwork>
      Data Server 1          Data Server N          Data Server 6
    +----------------+     +----------------+     +----------------+
    | HEADER         | ... | HEADER         | ... | HEADER         |
    +----------------+     +----------------+     +----------------+
    | guard:         | ... | guard:         | ... | guard:         |
    |   change_id: 3 | ... |   change_id: 3 | ... |   change_id: 3 |
    |   client_id: 6 | ... |   client_id: 6 | ... |   client_id: 6 |
    | payload_id : 0 | ... | payload_id : M | ... | payload_id : 5 |
    | crc32   :      | ... | crc32   :      | ... | crc32   :      |
    +----------------+     +----------------+     +----------------+
    | CHUNK          | ... | CHUNK          | ... | CHUNK          |
    +----------------+     +----------------+     +----------------+
    | data: ....     | ... | data: ....     | ... | data: ....     |
    +---+------------+     +--+-------------+     +-+--------------+
        |                     |                     |
        |                     |                     |
    +---+---------------------+---------------------+-----+
    |            Erasure Decoding (Transform Reverse)     |
    +---------------------+-------------------------------+
                          |
                          |
                  +-------+-----+
                  | data block  |
                  +-------------+
        </artwork>
      </figure>

      <t>
        When reading chunks via a READ operation, the client will decode
        them into data blocks as shown in
        <xref target='decoding_transformation' />.
      </t>

      <t>
        At this time, the
        client could detect issues in the integrity of the data. The handling
        and repair are out of the scope of this document and <bcp14>MUST</bcp14>
        be addressed in the document describing each erasure encoding type.
      </t>
      <section anchor='checking_crc' numbered='true' removeInRFC='false' toc='exclude'>
        <name>Checking the CRC32</name>
        <figure anchor='crc_on_wire'>
          <name>CRC32 on the Wire</name>
          <artwork>
        +------------------------------------+
        | CHUNK_READresok                    |
        +------------------------------------+
        | crr_eof: false                     |
        | crr_chunks[0]:                     |
        |        cr_crc: 0x21de8             |
        |        cr_owner:                   |
        |            co_guard:               |
        |                cg_change_id: 7     |
        |                cg_client_id: 6     |
        |        cr_chunk  :  ......         |
        +------------------------------------+
          </artwork>
        </figure>

        <t>
          Assuming the CHUNK_READ results as in <xref target='crc_on_wire' />,
          the crc32 needs to be checked in order to ensure data integrity. Conceptually,
          a header and payload can be built as shown in <xref target='crc_checking' />.
          The crc32 is calculated over the 3 fields as shown in the
          header and the cr_chunk. In this example, it is calculated
          to be 0x21de8. Thus this payload for the data server has data integrity.
        </t>

        <figure anchor='crc_checking'>
          <name>CRC32 Being Checked</name>
          <artwork>
        +---+----------------+
        | HEADER             |
        +--------------------+
        | guard:             |
        |   change_id: 7     |
        |   cleint_id: 6     |
        | payload_id  : 0    |
        | crc32    : 0       |
        +--------------------+
        | CHUNK              |
        +--------------------+
        | data:  ....        |
        +--------------------+
             Data Server 1
          </artwork>
        </figure>
      </section>
    </section>
  </section>

  <section anchor='errors' numbered='true' removeInRFC='false' toc='default'>
    <name>New NFSv4.2 Error Values</name>
    <figure anchor='code_errors'>
      <name>Errors XDR</name>
      <sourcecode type='xdr'>
///
/// /* Erasure Encoding errors start here */
///
/// NFS4ERR_XATTR2BIG      = 10096,/* xattr value is too big  */
/// NFS4ERR_ENCODING_NOT_SUPPORTED
///    = 10097,/* Encoding Type unsupported  */
/// NFS4ERR_PAYLOAD_NOT_CONSISTENT= 10098/* payload inconsitent  */
///
      </sourcecode>
    </figure>

    <t>
      The new error codes are shown in <xref target='code_errors' />.
    </t>

    <section anchor='errors_defs' numbered='true' removeInRFC='false' toc='default'>
      <name>Error Definitions</name>

      <table anchor='tbl_error_defs'>
        <name>Protocol Error Definitions</name>
        <thead>
          <tr>
            <th>Error</th>
            <th>Number</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr> <td>NFS4ERR_ENCODING_NOT_SUPPORTED</td> <td>10097</td> <td><xref target='NFS4ERR_ENCODING_NOT_SUPPORTED' /></td> </tr>
          <tr> <td>NFS4ERR_PAYLOAD_NOT_CONSISTENT</td> <td>10098</td> <td><xref target='NFS4ERR_PAYLOAD_NOT_CONSISTENT' /></td> </tr>
        </tbody>
      </table>

      <section anchor='NFS4ERR_ENCODING_NOT_SUPPORTED' numbered='true' removeInRFC='false' toc='exclude'>
        <name>NFS4ERR_ENCODING_NOT_SUPPORTED (Error Code 10097)</name>
        <t>
          The client requested a ffv2_encoding_type4 which the metadata server does not support. I.e.,
          if the client sends a layout_hint requesting an erasure encoding type that the
          metadata server does not support, this error code can be returned. The client
          might have to send the layout_hint several times to determine the overlapping
          set of supported erasure encoding types.
        </t>
      </section>
      <section anchor='NFS4ERR_PAYLOAD_NOT_CONSISTENT' numbered='true' removeInRFC='false' toc='exclude'>
        <name>NFS4ERR_PAYLOAD_NOT_CONSISTENT (Error Code 10098)</name>
        <t>
          The client encountered a payload in which the blocks were inconsistent and
          stays inconsistent. As the client can not tell if another client is
          actively writing, it informs the metadata server of this error via
          LAYOUTERROR4.  The metadata server can then arrange for
          repair of the file.
        </t>
      </section>
    </section>

    <section anchor='ops_to_errors' numbered='true' removeInRFC='false' toc='default'>
      <name>Operations and Their Valid Errors</name>

      <t>
        The operations and their valid errors are presented in <xref target='tbl_ops_to_errors' />.
        All error codes not defined in this document are defined in Section 15
        of <xref target='RFC8881' /> and Section 11 of <xref target='RFC7862' />.
      </t>

      <table anchor='tbl_ops_to_errors'>
        <name>Operations and Their Valid Errors</name>
        <thead>
          <tr>
            <th>Operation</th>
            <th>Errors</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>RESERVE</td>
            <td>
              NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,
              NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION, NFS4ERR_DELAY,
              NFS4ERR_DELEG_REVOKED, NFS4ERR_DQUOT, NFS4ERR_EXPIRED,
              NFS4ERR_FBIG, NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,
              NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,
              NFS4ERR_MOVED, NFS4ERR_NOFILEHANDLE, NFS4ERR_NOSPC,
              NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID, NFS4ERR_OPENMODE,
              NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_PNFS_IO_HOLE,
              NFS4ERR_PNFS_NO_LAYOUT, NFS4ERR_REP_TOO_BIG,
              NFS4ERR_REP_TOO_BIG_TO_CACHE, NFS4ERR_REQ_TOO_BIG,
              NFS4ERR_RESERVATION_CONFLICT, NFS4ERR_RETRY_UNCACHED_REP,
              NFS4ERR_ROFS, NFS4ERR_SERVERFAULT, NFS4ERR_STALE,
              NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE
            </td>
          </tr>
          <tr>
            <td>ROLLBACK_LIST</td>
            <td>
              NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,
              NFS4ERR_DEADSESSION, NFS4ERR_DELAY, NFS4ERR_DELEG_REVOKED,
              NFS4ERR_FHEXPIRED, NFS4ERR_GRACE, NFS4ERR_INVAL, NFS4ERR_IO,
              NFS4ERR_ISDIR, NFS4ERR_LOCKED, NFS4ERR_MOVED, NFS4ERR_NOENT,
              NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP, NFS4ERR_OPENMODE,
              NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_PNFS_IO_HOLE,
              NFS4ERR_PNFS_NO_LAYOUT, NFS4ERR_REP_TOO_BIG,
              NFS4ERR_REP_TOO_BIG_TO_CACHE, NFS4ERR_REQ_TOO_BIG,
              NFS4ERR_RESERVATION_CONFLICT, NFS4ERR_RETRY_UNCACHED_REP,
              NFS4ERR_SERVERFAULT, NFS4ERR_STALE, NFS4ERR_SYMLINK,
              NFS4ERR_TOO_MANY_OPS, NFS4ERR_WRONG_TYPE
            </td>
          </tr>
          <tr>
            <td>RESERVE_RECOVER</td>
            <td>
              NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,
              NFS4ERR_DELAY, NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,
              NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,
              NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP,
              NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_PERM,
              NFS4ERR_REP_TOO_BIG, NFS4ERR_REP_TOO_BIG_TO_CACHE,
              NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP,
              NFS4ERR_STALE, NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,
              NFS4ERR_WRONG_CRED, NFS4ERR_WRONG_TYPE
            </td>
          </tr>
          <tr>
            <td>RESERVE_RELEASE</td>
            <td>
              NFS4ERR_ACCESS, NFS4ERR_ADMIN_REVOKED, NFS4ERR_BADXDR,
              NFS4ERR_DELAY, NFS4ERR_FHEXPIRED, NFS4ERR_GRACE,
              NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_MOVED,
              NFS4ERR_NOENT, NFS4ERR_NOFILEHANDLE, NFS4ERR_NOTSUPP,
              NFS4ERR_OP_NOT_IN_SESSION, NFS4ERR_PERM,
              NFS4ERR_REP_TOO_BIG, NFS4ERR_REP_TOO_BIG_TO_CACHE,
              NFS4ERR_REQ_TOO_BIG, NFS4ERR_RETRY_UNCACHED_REP,
              NFS4ERR_STALE, NFS4ERR_SYMLINK, NFS4ERR_TOO_MANY_OPS,
              NFS4ERR_WRONG_CRED, NFS4ERR_WRONG_TYPE
            </td>
          </tr>
        </tbody>
      </table>
    </section>

    <section anchor='cb_ops_to_errors' numbered='true' removeInRFC='false' toc='default'>
      <name>Callback Operations and Their Valid Errors</name>

      <t>
        The callback operations and their valid errors are presented in <xref target='tbl_cb_ops_to_errors' />.
        All error codes not defined in this document are defined in Section 15
        of <xref target='RFC8881' /> and Section 11 of <xref target='RFC7862' />.
      </t>

      <table anchor='tbl_cb_ops_to_errors'>
        <name>Callback Operations and Their Valid Errors</name>
        <thead>
          <tr>
            <th>Callback Operation</th>
            <th>Errors</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>CB_RESERVE_REPAIR</td>
            <td>
              NFS4ERR_BADXDR,
              NFS4ERR_BAD_STATEID, NFS4ERR_DEADSESSION, NFS4ERR_DELAY,
              NFS4ERR_ENCODING_NOT_SUPPORTED,
              NFS4ERR_INVAL, NFS4ERR_IO, NFS4ERR_ISDIR, NFS4ERR_LOCKED,
              NFS4ERR_NOTSUPP, NFS4ERR_OLD_STATEID,
              NFS4ERR_SERVERFAULT, NFS4ERR_STALE,
            </td>
          </tr>
        </tbody>
      </table>
    </section>

    <section anchor='errors_to_ops' numbered='true' removeInRFC='false' toc='default'>
      <name>Errors and the Operations That Use Them</name>

      <t>
        The operations and their valid errors are presented in <xref target='tbl_error_to_ops' />.
        All operations not defined in this document are defined in Section 18
        of <xref target='RFC8881' /> and Section 15 of <xref target='RFC7862' />.
      </t>

      <table anchor='tbl_error_to_ops'>
        <name>Errors and the Operations That Use Them</name>
        <thead>
          <tr>
            <th>Error</th>
            <th>Operations</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>NFS4ERR_ENCODING_NOT_SUPPORTED</td>
            <td>
              CB_RESERVE_REPAIR, LAYOUTGET
            </td>
          </tr>
          <tr>
            <td>NFS4ERR_RESERVATION_CONFLICT</td>
            <td>
              RESERVE
            </td>
          </tr>
          <tr>
            <td>NFS4ERR_RESERVATION_FILE</td>
            <td>
              CLOSE, LOCK, LOCKT, LOCKU, LOOKUP, LOOKUPP, OPEN, OPENATTR, READLINK,
              REMOVE, RENAME, SETATTR, VERIFY
            </td>
          </tr>
          <tr>
            <td>NFS4ERR_RESERVATION_HELD</td>
            <td>
              COMMIT, READ, WRITE
            </td>
          </tr>
          <tr>
            <td>NFS4ERR_RESERVATION_OUT_OF_RANGE</td>
            <td>
              COMMIT, READ, WRITE
            </td>
          </tr>
        </tbody>
      </table>
    </section>
  </section>

  <section anchor='EXCHGID4_FLAG_USE_ERASURE_DS' numbered='true' removeInRFC='false' toc='default'>
    <name>EXCHGID4_FLAG_USE_PNFS_DS</name>
    <figure anchor='code_EXCHGID4_FLAG_USE_ERASURE_DS'>
      <name>XDR for EXCHGID4_FLAG_USE_PNFS_DS</name>
      <sourcecode type='xdr'>
/// const EXCHGID4_FLAG_USE_ERASURE_DS      = 0x00100000;
      </sourcecode>
    </figure>

    <t>
      When a data server connects to a metadata server it
      can via EXCHANGE_ID (see Section 18.35 of <xref target='RFC8881' />) state its pNFS role.
      The data server can use EXCHGID4_FLAG_USE_ERASURE_DS
      (see <xref target='code_EXCHGID4_FLAG_USE_ERASURE_DS' />)
      to indicate that it supports the new NFSv4.2 operations
      introduced in this document.  Section 13.1 <xref target='RFC8881' /> describes the
      interaction of the various pNFS roles masked by EXCHGID4_FLAG_MASK_PNFS.
      However, that does not mask out EXCHGID4_FLAG_USE_ERASURE_DS.
      I.e., EXCHGID4_FLAG_USE_ERASURE_DS can be used in combination
      with all of the pNFS flags.
    </t>
    <t>
      If the data server sets EXCHGID4_FLAG_USE_ERASURE_DS during the
      EXCHANGE_ID operation, then it <bcp14>MUST</bcp14> support:
      RESERVE, ROLLBACK_LIST, RESERVE_RECOVER, RESERVE_RELEASE,
      and RESERVE_SWAP. Further, note that this support is
      orthogonal to the Erasure Encoding Type selected. The
      data server is unaware of which type is driving the I/O.
    </t>
  </section>

  <section anchor='attrs' numbered='true' removeInRFC='false' toc='default'>
    <name>New NFSv4.2 Attributes</name>
    <section anchor='fattr4_encoding_block_size' numbered='true' removeInRFC='false' toc='default'>
      <name>Attribute 88: fattr4_encoding_block_size</name>
      <figure anchor='code_fattr4_encoding_block_size'>
        <name>XDR for fattr4_encoding_block_size</name>
        <sourcecode type='xdr'>
/// typedef size_t                    fattr4_encoding_block_size;
///
/// const FATTR4_ENCODING_BLOCK_SIZE  = 88;
///
        </sourcecode>
      </figure>
      <t>
        The new attribute fattr4_encoding_block_size (see
        <xref target='code_fattr4_encoding_block_size'/>) is
        an <bcp14>OPTIONAL</bcp14> to NFSv4.2 attribute which
        <bcp14>MUST</bcp14> be supported if the metadata server supports
        the Flexible File Version 2 Layout Type. By querying it, the
        client can determine the data block size it is to use
        when encoding the data blocks to chunks.
      </t>
    </section>
  </section>

  <section anchor='common_data_structure' numbered='true' removeInRFC='false' toc='default'>
    <name>New NFSv4.2 Common Data Structures</name>
    <section anchor='chunk_guard4' numbered='true' removeInRFC='false' toc='default'>
      <name>chunk_guard4</name>
      <figure anchor='code_chunk_guard4'>
        <name>XDR for chunk_guard4</name>
        <sourcecode type='xdr'>
/// struct chunk_guard4 {
///     uint32_t   cg_change_id;
///     uint32_t   cg_client_id;
/// };
        </sourcecode>
      </figure>
      <t>
        The chunk_guard4 (see <xref target='code_chunk_guard4' /> is effectively a 64 bit value, with
        the upper 32 bits, cg_change_id,  being the current time in ms and the lower 32
        bits, cg_client_id, being an unique id established when the client did the
        EXCHANGE_ID operation (see Section 18.35 of <xref target='RFC8881' />)
        with the metadata server. The lower 32 bits are set passed
        back in the LAYOUTGET operation (see Section 18.43 of <xref target='RFC8881' />)
        as the fml_client_id (see <xref target='ffv2_mirror4' />).
      </t>
      <t>
        When comparing two chunk_guard4 data stuctures src and dst, using the standard
        comparision results of -1 for src &amp; dst, 0 for src = dst, and +1 for
        src &gt; dst, the algorithm is shown in <xref target='code_chunk_guard4_cmp' />.
      </t>
      <figure anchor='code_chunk_guard4_cmp'>
        <name>Comparing two chunk_guard4</name>
        <sourcecode type='c'>
/// int compare_chunk_guard(chunk_guard4 src, chunk_guard4 dst)
/// {
///     if (src.cg_change_id &amp; dst.cg_change_id) {
///         return -1;
///     } else if (src.cg_change_id &gt; dst.cg_change_id) {
///         return 1;
///     } else if (src.cg_client_id &amp; dst.cg_client_id ) {
///         return -1;
///     } else if (src.cg_client_id &gt; dst.cg_client_id) {
///         return 1;
///     }
///     return 0;
/// };
        </sourcecode>
      </figure>
      <t>
        <cref anchor='AI40' source='TH'>
          Do we need the comparison algorithm?
        </cref>
      </t>
    </section>

    <section anchor='chunk_owner4' numbered='true' removeInRFC='false' toc='default'>
      <name>chunk_owner4</name>
      <figure anchor='code_chunk_owner4'>
        <name>XDR for code_chunk_owner4</name>
        <sourcecode type='xdr'>
/// struct chunk_owner4 {
///     chunk_guard4   co_guard;
///     uint32_t       co_id;
/// };
        </sourcecode>
      </figure>
      <t>
        The chunk_owner4 (see <xref target='code_chunk_owner4' />)
        is used to determine when and by whom a block was written.
        The co_id is used to identify the block and <bcp14>MUST</bcp14>
        be the index of the chunk within the file. I.e., it is the
        offset of the start of the chunk divided by the chunk length.
        The co_guard is a chunk_guard4 (see <xref target='chunk_guard4' />
        used to identify a given transaction.
      </t>
      <t>
        The co_guard is like the change attribute
        (see Section 5.8.1.4 of <xref target='RFC8881' format='default'
        sectionFormat='of' />) in that each chunk write by a given
        client has to have an unique co_guard. I.e., it can
        be determined which transaction across all data files that
        a chunk corresponds.
      </t>
    </section>
  </section>

  <section anchor='ops' numbered='true' removeInRFC='false' toc='default'>
    <name>New NFSv4.2 Operations</name>

    <figure anchor='code_ops'>
      <name>Operations XDR</name>
      <sourcecode type='xdr'>
///
/// /* New operations for Erasure Encoding start here */
///
///  OP_CHUNK_COMMIT        = 77,
///  OP_CHUNK_READ          = 78,
///  OP_CHUNK_SWAP          = 79,
///  OP_CHUNK_UNLOCK        = 80,
///  OP_CHUNK_WRITE         = 81,
///  OP_CHUNK_WRITE_SWAP    = 82,
///  OP_CHUNK_WRITE_SWAP_GUARD = 83,
///  OP_GUARD_SWAP          = 84,
///  OP_HEADER_READ         = 85,
///  OP_ROLLBACK_CLOSE      = 86,
///  OP_ROLLBACK_LIST       = 87,
///  OP_ROLLBACK_OPEN       = 88,
///  OP_SWAP                = 89,
///
      </sourcecode>
    </figure>


    <table anchor='tbl_op_defs'>
      <name>Protocol Operation Definitions</name>
      <thead>
        <tr>
          <th>Operation</th>
          <th>Number</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr> <td>CHUNK_COMMIT</td> <td>77</td> <td><xref target='CHUNK_COMMIT' /></td> </tr>
        <tr> <td>CHUNK_READ</td> <td>78</td> <td><xref target='CHUNK_READ' /></td> </tr>
        <tr> <td>CHUNK_SWAP</td> <td>79</td> <td><xref target='CHUNK_READ' /></td> </tr>
        <tr> <td>CHUNK_UNLOCK</td> <td>80</td> <td><xref target='CHUNK_READ' /></td> </tr>
        <tr> <td>CHUNK_WRITE</td> <td>81</td> <td><xref target='CHUNK_WRITE' /></td> </tr>
        <tr> <td>CHUNK_WRITE_SWAP_GUARD</td> <td>82</td> <td><xref target='CHUNK_WRITE' /></td> </tr>
        <tr> <td>GUARD_SWAP</td> <td>83</td> <td><xref target='CHUNK_WRITE' /></td> </tr>
        <tr> <td>HEADER_READ</td> <td>84</td> <td><xref target='HEADER_READ' /></td> </tr>
        <tr> <td>ROLLBACK_CLOSE</td> <td>85</td> <td><xref target='ROLLBACK_LIST' /></td> </tr>
        <tr> <td>ROLLBACK_LIST</td> <td>86</td> <td><xref target='ROLLBACK_LIST' /></td> </tr>
        <tr> <td>ROLLBACK_OPEN</td> <td>87</td> <td><xref target='ROLLBACK_LIST' /></td> </tr>
        <tr> <td>SWAP</td> <td>88</td> <td><xref target='ROLLBACK_LIST' /></td> </tr>
      </tbody>
    </table>

    <section anchor='CHUNK_COMMIT' numbered='true' removeInRFC='false' toc='default'>
      <name>Operation 77: CHUNK_COMMIT - Activate Cached Chunk Data</name>
      <section anchor='CHUNK_COMMIT4args' numbered='true' removeInRFC='false' toc='exclude'>
        <name>ARGUMENTS</name>
        <figure anchor='code_CHUNK_COMMIT4args'>
          <name>XDR for CHUNK_COMMIT4args</name>
          <sourcecode type='xdr'>
/// struct CHUNK_COMMIT4args {
///     /* CURRENT_FH: file */
///     offset4         cca_offset;
///     count4          cca_count;
///     chunk_owner4    cca_chunks&lt;&gt;;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='CHUNK_COMMIT4res' numbered='true' removeInRFC='false' toc='exclude'>
        <name>RESULTS</name>
        <figure anchor='code_CHUNK_COMMIT4resok'>
          <name>XDR for CHUNK_COMMIT4resok</name>
          <sourcecode type='xdr'>
/// struct CHUNK_COMMIT4resok {
///     verifier4       ccr_writeverf;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_CHUNK_COMMIT4res'>
          <name>XDR for CHUNK_COMMIT4res</name>
          <sourcecode type='xdr'>
/// union CHUNK_COMMIT4res switch (nfsstat4 ccr_status) {
///     case NFS4_OK:
///         CHUNK_COMMIT4resok   ccr_resok4;
///     default:
///         void;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='CHUNK_COMMIT_desc' numbered='true' removeInRFC='false' toc='exclude'>
        <name>DESCRIPTION</name>
        <t>
          CHUNK_COMMIT is COMMIT (see Section 18.3 of <xref target='RFC8881'
          format='default' sectionFormat='of' />) with additional semantics
          over the chunk_owner activating the blocks. As such, all of
          the normal semantics of COMMIT directly apply.
        </t>
        <t>
          The main difference between the two operations is that CHUNK_COMMIT
          works on blocks and not a raw data stream. As such cca_offset
          is the starting block offset in the file and not the byte
          offset in the file. Some erasure encoding types can have
          different block sizes depending on the
          block type. Further, cca_count is a count of blocks to activate
          and not bytes to activate.
        </t>
        <t>
          Further, while it may appear that the combination of cca_offset
          and cca_count are redundant to cca_chunks, the purpose of
          cca_chunks is to allow the data server to differentiate between
          potentially multiple pending blocks.
        </t>
      </section>
    </section>

    <section anchor='CHUNK_READ' numbered='true' removeInRFC='false' toc='default'>
      <name>Operation 78: CHUNK_READ - Read Chunks from File</name>
      <section anchor='CHUNK_READ4args' numbered='true' removeInRFC='false' toc='exclude'>
        <name>ARGUMENTS</name>
        <figure anchor='code_CHUNK_READ4args'>
          <sourcecode type='xdr'>
/// struct CHUNK_READ4args {
///     /* CURRENT_FH: file */
///     stateid4    cra_stateid;
///     offset4     cra_offset;
///     count4      cra_count;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='CHUNK_READ4res' numbered='true' removeInRFC='false' toc='exclude'>
        <name>RESULTS</name>

        <figure anchor='code_read_chunk4'>
          <sourcecode type='xdr'>
/// struct read_chunk4 {
///     uint32_t        cr_crc;
///     uint32_t        cr_effective_len;
///     chunk_owner4    cr_owner;
///     uint32_t        cr_payload_id;
///     opaque          cr_chunk&lt;&gt;;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_CHUNK_READ4resok'>
          <sourcecode type='xdr'>
/// struct CHUNK_READ4resok {
///     bool        crr_eof;
///     read_chunk4 crr_chunks&lt;&gt;;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_CHUNK_READ4res'>
          <sourcecode type='xdr'>
/// union CHUNK_READ4res switch (nfsstat4 crr_status) {
///     case NFS4_OK:
///          CHUNK_READ4resok     crr_resok4;
///     default:
///          void;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='CHUNK_READ_desc' numbered='true' removeInRFC='false' toc='exclude'>
        <name>DESCRIPTION</name>
        <t>
          CHUNK_READ is READ (see Section 18.22 of <xref target='RFC8881'
          format='default' sectionFormat='of' />) with additional semantics
          over the chunk_owner. As such, all of the normal semantics of READ directly apply.
        </t>
        <t>
          The main difference between the two operations is that CHUNK_READ
          works on blocks and not a raw data stream. As such cra_offset
          is the starting block offset in the file and not the byte
          offset in the file. Some erasure encoding types can have
          different block sizes depending on the
          block type. Further, cra_count is a count of blocks to read
          and not bytes to read.
        </t>
        <t>
          When reading a set of blocks across the data servers, it can be
          the case that some data servers do not have any data at that
          location. In that case, the server either returns crr_eof
          if the cra_offset exceeds the number of blocks that
          the data server is aware or it returns an empty block
          for that block.
        </t>

        <t>
          For example, in <xref target='example_CHUNK_READ4args_1' />, the
          client asks for 4 blocks starting with the 3rd block in the file.
          The second data server responds as in <xref target='example_CHUNK_READ4res_1' />.
          The client would read this as there is valid data for blocks 2 and
          4, there is a hole at block 3, and there is no data for block 5.
          The data server <bcp14>MUST</bcp14> calculate a valid
          cr_crc for block 3 based on the generated fields.
        </t>

        <figure anchor='example_CHUNK_READ4args_1'>
          <artwork>
                Data Server 2
        +--------------------------------+
        | CHUNK_READ4args                |
        +--------------------------------+
        | cra_stateid: 0                 |
        | cra_offset: 2                  |
        | cra_count: 4                   |
        +----------+---------------------+
          </artwork>
        </figure>

      <figure anchor='example_CHUNK_READ4res_1'>
        <artwork>
                Data Server 2
        +--------------------------------+
        | CHUNK_READ4resok               |
        +--------------------------------+
        | crr_eof: true                  |
        | crr_chunks[0]:                 |
        |     cr_crc: 0x3faddace         |
        |     cr_owner:                  |
        |         co_chunk_id: 2         |
        |         co_guard:              |
        |             cg_change_id: 3    |
        |             cg_client_id: 6    |
        |     cr_payload_id: 1           |
        |     cr_chunk: ....             |
        | crr_chunks[0]:                 |
        |     cr_crc: 0xdeade4e5         |
        |     cr_owner:                  |
        |         co_chunk_id: 3         |
        |         co_guard:              |
        |             cg_change_id: 0    |
        |             cg_client_id: 0    |
        |     cr_payload_id: 1           |
        |     cr_chunk: 0000...00000     |
        | crr_chunks[0]:                 |
        |     cr_crc: 0x7778abcd         |
        |     cr_owner:                  |
        |         co_chunk_id: 4         |
        |         co_guard:              |
        |             cg_change_id: 3    |
        |             cg_client_id: 6    |
        |     cr_payload_id: 1           |
        |     cr_chunk: ....             |
        +--------------------------------+
        </artwork>
      </figure>

      </section>
    </section>

    <section anchor='HEADER_READ' numbered='true' removeInRFC='false' toc='default'>
      <name>Operation 79: HEADER_READ - Read Chunk Header from File</name>
      <section anchor='HEADER_READ4args' numbered='true' removeInRFC='false' toc='exclude'>
        <name>ARGUMENTS</name>
        <figure anchor='code_HEADER_READ4args'>
          <sourcecode type='xdr'>
/// struct HEADER_READ4args {
///     /* CURRENT_FH: file */
///     stateid4    hra_stateid;
///     offset4     hra_offset;
///     count4      hra_count;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='HEADER_READ4res' numbered='true' removeInRFC='false' toc='exclude'>
        <name>RESULTS</name>
        <figure anchor='code_HEADER_READ4resok'>
          <sourcecode type='xdr'>
/// struct HEADER_READ4resok {
///     bool            hrr_eof;
///     chunk_owner4    hrr_chunks&lt;&gt;;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_HEADER_READ4res'>
          <sourcecode type='xdr'>
/// union HEADER_READ4res switch (nfsstat4 hrr_status) {
///     case NFS4_OK:
///         HEADER_READ4resok     hrr_resok4;
///     default:
///         void;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='HEADER_READ4_desc' numbered='true' removeInRFC='false' toc='exclude'>
        <name>DESCRIPTION</name>
        <t>
          HEADER_READ differs from CHUNK_READ in that it only reads
          chunk headers in the desired data range.
        </t>
      </section>
    </section>

    <section anchor='ROLLBACK_CHUNK' numbered='true' removeInRFC='false' toc='default'>
      <name>Operation 80: ROLLBACK_CHUNK - Rollback Cached Chunk Data</name>
      <section anchor='ROLLBACK_CHUNK4args' numbered='true' removeInRFC='false' toc='exclude'>
        <name>ARGUMENTS</name>
        <figure anchor='code_ROLLBACK_CHUNK4args'>
          <sourcecode type='xdr'>
/// struct ROLLBACK_CHUNK4args {
///     /* CURRENT_FH: file */
///     offset4         cra_offset;
///     count4          cra_count;
///     chunk_owner4    cra_chunks&lt;&gt;;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='ROLLBACK_CHUNK4res' numbered='true' removeInRFC='false' toc='exclude'>
        <name>RESULTS</name>
        <figure anchor='code_ROLLBACK_CHUNK4resok'>
          <sourcecode type='xdr'>
/// struct ROLLBACK_CHUNK4resok {
///     verifier4       crr_writeverf;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_ROLLBACK_CHUNK4res'>
          <sourcecode type='xdr'>
/// union ROLLBACK_CHUNK4res switch (nfsstat4 crr_status) {
///     case NFS4_OK:
///         ROLLBACK_CHUNK4resok   crr_resok4;
///     default:
///         void;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='ROLLBACK_CHUNK_desc' numbered='true' removeInRFC='false' toc='exclude'>
        <name>DESCRIPTION</name>
        <t>
          ROLLBACK_CHUNK is a new form like COMMIT (see Section 18.3 of <xref target='RFC8881'
          format='default' sectionFormat='of' />) with additional semantics
          over the chunk_owner the rolling back the writing of blocks. As such, all of
          the normal semantics of COMMIT directly apply.
        </t>

        <t>
          The main difference between the two operations is that ROLLBACK_CHUNK
          works on blocks and not a raw data stream. As such cra_offset
          is the starting block offset in the file and not the byte
          offset in the file. Some erasure encoding types can have
          different block sizes depending on the
          block type. Further, cra_count is a count of blocks to rollback
          and not bytes to rollback.
        </t>
        <t>
          Further, while it may appear that the combination of cra_offset
          and cra_count are redundant to cra_chunks, the purpose of
          cra_chunks is to allow the data server to differentiate between
          potentially multiple pending blocks.
        </t>

        <t>
          ROLLBACK_CHUNK deletes prior CHUNK_WRITE transactions. In case of write
          holes, it allows the client to undo transactions to repair the file.
        </t>
      </section>
    </section>

    <section anchor='CHUNK_WRITE' numbered='true' removeInRFC='false' toc='default'>
      <name>Operation 81: CHUNK_WRITE - Write Chunks to File</name>
      <section anchor='CHUNK_WRITE4args' numbered='true' removeInRFC='false' toc='exclude'>
        <name>ARGUMENTS</name>

        <figure anchor='code_cw_args_flags'>
          <sourcecode type='xdr'>
/// const CHUNK_WRITE_FLAGS_UPDATE_HEADER_ONLY   = 0x00000001;
/// const CHUNK_WRITE_FLAGS_ACTIVATE_IF_EMPTY    = 0x00000002;
          </sourcecode>
        </figure>

        <figure anchor='code_write_chunk4'>
          <sourcecode type='xdr'>
/// struct write_chunk4 {
///     uint32_t        cw_crc;
///     uint32_t        cw_flags;
///     opaque          cw_chunk&lt;&gt;;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_write_chunk_guard4'>
          <sourcecode type='xdr'>
/// union write_chunk_guard4 (bool cwg_check) {
///     case TRUE:
///         chunk_guard4   cwg_guard;
///     case FALSE:
///         void;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_CHUNK_WRITE4args'>
          <sourcecode type='xdr'>
/// struct CHUNK_WRITE4args {
///     /* CURRENT_FH: file */
///     stateid4           cwa_stateid;
///     offset4            cwa_offset;
///     stable_how4        cwa_stable;
///     chunk_owner4       cwa_owner;
///     uint32_t           cwa_payload_id;
///     write_chunk_guard4 cwa_guard;
///     write_chunk4       cwa_data&lt;&gt;;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='CHUNK_WRITE4res' numbered='true' removeInRFC='false' toc='exclude'>
        <name>RESULTS</name>

        <figure anchor='code_CHUNK_WRITE4resok'>
          <sourcecode type='xdr'>
/// struct CHUNK_WRITE4resok {
///     count4          cwr_count;
///     stable_how4     cwr_committed;
///     verifier4       cwr_writeverf;
///     chunk_owner4    cwr_owners&lt;&gt;;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_CHUNK_WRITE4res'>
          <sourcecode type='xdr'>
/// union CHUNK_WRITE4res switch (nfsstat4 cwr_status) {
///     case NFS4_OK:
///         CHUNK_WRITE4resok    cwr_resok4;
///     default:
///         void;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='CHUNK_WRITE_desc' numbered='true' removeInRFC='false' toc='exclude'>
        <name>DESCRIPTION</name>
        <t>
          CHUNK_WRITE is WRITE (see Section 18.32 of <xref target='RFC8881'
          format='default' sectionFormat='of' />) with additional semantics
          over the chunk_owner and the activation of blocks. As such, all of
          the normal semantics of WRITE directly apply.
        </t>
        <t>
          The main difference between the two operations is that CHUNK_WRITE
          works on blocks and not a raw data stream. As such cwa_offset
          is the starting block offset in the file and not the byte
          offset in the file. Some erasure encoding types can have
          different block sizes depending on the
          block type. Further, cwr_count is a count of written blocks
          and not written bytes.
        </t>
        <t>
          If cwa_stable is FILE_SYNC4, the
          data server <bcp14>MUST</bcp14> commit the written header and block data plus all file system metadata to
          stable storage before returning results.  This corresponds to the
          NFSv2 protocol semantics.  Any other behavior constitutes a protocol
          violation.  If cwa_stable is DATA_SYNC4, then the data server <bcp14>MUST</bcp14> commit all
          of the header and block data  to stable storage and enough of the metadata to retrieve
          the data before returning.  The data server implementer is free to
          implement DATA_SYNC4 in the same fashion as FILE_SYNC4, but with a
          possible performance drop.  If cwa_stable is UNSTABLE4, the data server is
          free to commit any part of the header and  block data and the metadata to stable
          storage, including all or none, before returning a reply to the
          client.  There is no guarantee whether or when any uncommitted data
          will subsequently be committed to stable storage.  The only
          guarantees made by the data server are that it will not destroy any data
          without changing the value of writeverf and that it will not commit
          the data and metadata at a level less than that requested by the
          client.
        </t>
        <t>
          The activation of header and block data interacts with the co_activated
          for each of the written blocks. If the data is not committed
          to stable storage then the co_activated field <bcp14>MUST NOT</bcp14>
          be set to true. Once the data is committed to stable storage, then
          the data server can set the block's co_activated if one of these
          conditions apply:
        </t>
        <ul>
          <li>
            it is the first write to that block and the CHUNK_WRITE_FLAGS_ACTIVATE_IF_EMPTY flag is set
          </li>
          <li>
            the CHUNK_COMMIT is issued later for that block.
          </li>
        </ul>
        <t>
          There are subtle interactions with write holes caused by racing
          clients. One client could win the race in each case, but because
          it used a cwa_stable of UNSTABLE4, the subsequent writes from
          the second client with a cwa_stable of FILE_SYNC4 can be awarded
          the co_activated being set to true for each of the blocks in
          the payload.
        </t>
        <t>
          Finally, the interaction of cwa_stable can cause a client to
          mistakenly believe that by the time it gets the response of
          co_activated of false, that the blocks are not activated. A
          subsequent CHUNK_READ or HEADER_READ might show that
          the co_activated is true without any interaction by the client
          via CHUNK_COMMIT.
        </t>

        <section anchor='guarded_write' numbered='true' removeInRFC='false' toc='exclude'>
          <name>Guarding the Write</name>
          <t>
            A guarded CHUNK_WRITE is when the writing of a block
            <bcp14>MUST</bcp14> fail if cwa_guard.cwg_check is set
            and the target chunk does not have both the same change_id
            cwa_guard.as the cwg_guard.cg_change_id and the same cwa_guard.cg_change_id as the
            cwa_guard.cwg_guard.cg_change_id. This is useful in read-update-write
            scenarios. The client reads a block, updates it, and
            is prepared to write it back. It guards the write such
            that if another writer has modified the block, the
            data server will reject the modification.
          </t>
          <t>
            As the chunk_guard4 (see <xref target='code_chunk_guard4' />
            does not have a chunk_id and the CHUNK_WRITE applies
            to all blocks in the range of cwa_offset to the length
            of cwa_data, then each of the target blocks
            <bcp14>MUST</bcp14> have the same cg_change_id and
            cg_client_id. The client <bcp14>SHOULD</bcp14> present
            the smallest set of blocks as possible to meet this
            requirement.
          </t>

          <t>
            <cref anchor='AI28' source='TH'>
              Is the DS supposed to vet all blocks first or proceed to
              the first error? Or do all blocks and return an array
              of errors? (This last one is a no-go.) Also, if we do
              the vet first, what happens if a CHUNK_WRITE comes in
              after the vetting? Are we to lock the file during this
              process. Even if we do that, we still have the issue
              of multiple DSes.
            </cref>
          </t>
        </section>

        <section anchor='update_header' numbered='true' removeInRFC='false' toc='exclude'>
          <name>Updating the Header Only</name>
          <t>
            Some erasure encoding types keep their blocks in plain text and
            have parity blocks in order to provide integrity. A common
            configuration for Reed Solomon is 4 active blocks, 2
            parity blocks, and 2 spares. Assuming 4kB data blocks,
            then each payload delivers 16kB of data and 8kB of parity.
            If the application modifies the first data block, then
            all that needs to change is the first active block and the
            two parity blocks in the payload.
          </t>
          <t>
            In any other approach, only 12kB of the total 24kB has to
            be written to storage. If that is attempted in the Flexible
            Files Version 2 Layout Type, then the payload will be deemed
            as inconsistent. The reason for this is that the change_id
            for the unmodified blocks will not match those of the
            modified blocks.
          </t>
          <t>
            The CHUNK_WRITE_FLAGS_UPDATE_HEADER_ONLY flag in cw_flags
            can be used to save
            the transmission of the blocks. If it is set, then
            the cw_chunk is ignored. It <bcp14>MUST</bcp14> be
            empty. The client <bcp14>MUST</bcp14> only
            modify both the cw_crc and the cwa_owner.co_change_id
            fields in this case. The cw_crc <bcp14>MUST</bcp14>
            change as the cwa_owner.co_change_id has been modified
            (see <xref target='calculating_crc' />).
          </t>
          <t>
            For the
            purpose of computing the activation state of the block,
            The data server <bcp14>MUST</bcp14> treat this as
            an overwrite. Thus, in the response, co_activated
            <bcp14>MUST</bcp14> be false.
          </t>
        </section>
      </section>
    </section>

    <section anchor='RESERVE' numbered='true' removeInRFC='false' toc='default'>
      <name>Operation 77: RESERVE - Reserve a byte range for writing</name>
      <section anchor='RESERVE4args' numbered='true' removeInRFC='false' toc='exclude'>
        <name>ARGUMENTS</name>
        <figure anchor='code_RESERVE4args'>
          <sourcecode type='xdr'>
/// struct RESERVE4args {
///     /* CURRENT_FH: file */
///     stateid4        ra_stateid;
///     ffv2_key4       ra_key;
///     clientid4       ra_client_id;
///     offset4         ra_offset;
///     length4         ra_length;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='RESERVE4res' numbered='true' removeInRFC='false' toc='exclude'>
        <name>RESULTS</name>
        <figure anchor='code_RESERVE4resok'>
          <sourcecode type='xdr'>
/// struct RESERVE4resok {
///     uint32_t        rr_reservation_id;
///     offset4         rr_offset;
///     length4         rr_length;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_RESERVE4resconflict'>
          <sourcecode type='xdr'>
/// struct RESERVE4resconflict {
///     offset4        rrc_offset;
///     count4         rrc_count;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_RESERVE4res'>
          <sourcecode type='xdr'>
/// union RESERVE4res switch (nfsstat4 rr_status) {
///     case NFS4_OK:
///         /* New CURRENT_FH: opened reservation file */
///         RESERVE4resok         rr_resok4;
///     case NFS4ERR_RESERVATION_CONFLICT:
///         RESERVE4resconflict   rr_resconflict4;
///     default:
///         void;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='RESERVE4_desc' numbered='true' removeInRFC='false' toc='exclude'>
        <name>DESCRIPTION</name>
        <t>
          RESERVE is a new operation to reserve for writing a section of a file
          given from the offset of ra_offset to a range of ra_offset + ra_length
          bytes. If the server already has a reservation that overlaps the
          requested range, then the server <bcp14>MUST</bcp14> return an error
          of NFS4ERR_RESERVATION_CONFLICT and fill in the RESERVE4resconflict
          (see <xref target='code_RESERVE4resconflict' />)
          with at least one of the conflicting reservations. I.e., rrc_offset
          would be an earlier ra_offset and rrc_count would be an earlier
          ra_length supplied by another client (or even the same client) during
          a RESERVE operation.
        </t>
        <t>
          Upon success, the rr_reservation_id (see <xref target='code_RESERVE4resok' />)
          identifier is an unique reference to the reservation and it <bcp14>MUST</bcp14>
          persist across server restarts. As the ra_offset might not be aligned
          on a data block of the server, rr_offset is the start of the data
          block such that rr_offset &lt;= ra_offset. Further, since the
          ra_length might also not be aligned at the end of a data block,
          rr_length &gt;= ra_length. The client <bcp14>MUST</bcp14>
          detect the difference and make sure to copy these excess data
          from the data file to the reservation file. I.e., if the
          client only acts on the range of ra_offset to ra_length,
          then it might inadvertantly overwrite the excess data
          with garbage.
        </t>
        <t>
          RESERVE creates a new reservation file on the server and
          populates the current filehandle for it. As the reservation
          file is not visible in the server namespace, the client
          <bcp14>MUST</bcp14> issue a GETATTR(fh) (see Section
          18.7 of <xref target='RFC8881' />) to get the filehandle.
          The reservation file <bcp14>MUST</bcp14> have the exact
          same authorization as the file (see Section 2.8.1 of <xref target='RFC8881' />),
          which means the attributes mode, owner,
          owner_group, acl, dacl, and sacl <bcp14>MUST</bcp14> track those
          of the file. I.e., they <bcp14>MUST NOT</bcp14> be modified by
          SETATTR on the reservation file and if they are modified on
          the file, they <bcp14>MUST</bcp14> be modified equivalently
          on the reservation file. Finally, the values of time_access,
          time_backup, time_create, time_metadata, time_modify, and change
          <bcp14>MUST</bcp14> initially be those of the file, but they
          <bcp14>MUST</bcp14> be tracked separately from the file.
        </t>
        <t>
          RESERVE <bcp14>MUST</bcp14> check for write access just like
          the WRITE operation. I.e., if the owner does not have write
          permissions, if it is a read-only filesystem, etc, the
          appropriate error <bcp14>MUST</bcp14> be returned to the
          RESERVE operation.
        </t>
        <t>
          The server <bcp14>MUST</bcp14> persist the ra_key and the ra_client_id
          in order to authenticate subsequent operations on the reservation file.
          These are not visible attributes for the reservation file. The
          server <bcp14>MUST</bcp14> not reveal the ra_key in a GETATTR result.
          If the client loses the ra_key, then server <bcp14>MUST</bcp14>
          allow for local administrative action to release the reservation.
          Note that such means are beyond the scope of this document.
        </t>
        <t>
          Whilst RESERVE is presented in terms of pNFS and
          the Flexible File Version 2 Layout Type, nothing prevents it
          from being used with non-pNFS servers. I.e., RESERVE is
          not aware of the parallel aspect, it is the metadata server
          and client which are aware of that relationship.
        </t>
        <t>
          As such the ra_stateid follows the rules for a WRITE request
          (see Section 18.32.3 of of <xref target='RFC8881'
          />) for non-pNFS servers and
          the rules for Loosely Coupled I/O for pNFS (see Section 2.3.1
          of <xref target='RFC8435' />).
          I.e., an anonymous stateid is presented.
        </t>
        <t>
          The reservation file <bcp14>MUST NOT</bcp14> be recovered
          during grace recovery. The file <bcp14>MUST</bcp14> be
          recovered and then the client can use RESERVE_RECOVER
          to get the reservation filehandle.
        </t>
        <t>
          A file with a reservation is consisdered opened, even
          if it is not reclaimed during grace recovery. I.e.,
          the reservation prevents the file from being deleted
          by normal means. A REMOVE on the file <bcp14>MUST</bcp14>
          result in an error of NFS4ERR_RESERVATION_FILE.
        </t>
        <t>
          The entire file can be reserved with ra_offset being 0
          and ra_length being NFS4_UINT64_MAX. This also allows for
          appending data to an existing file. The server <bcp14>MUST</bcp14> return
          NFS4ERR_INVAL under the following combinations of ra_length and ra_offset:
        </t>

        <ul>
          <li>ra_length is equal to zero.</li>

          <li>
            ra_length is not equal to NFS4_UINT64_MAX, and the sum of ra_length and
            ra_offset exceeds NFS4_UINT64_MAX.
          </li>
        </ul>
        <t>
          The state of fattr4reserved_state for the reservation file <bcp14>MUST</bcp14>
          be persisted to NFS4_RESERVED_INITIALIZED.
        </t>
      </section>
    </section>

    <section anchor='ROLLBACK_LIST' numbered='true' removeInRFC='false' toc='default'>
      <name>Operation 78: ROLLBACK_LIST - Get information on a byte range for writing</name>
      <section anchor='ROLLBACK_LIST4args' numbered='true' removeInRFC='false' toc='exclude'>
        <name>ARGUMENTS</name>
        <figure anchor='code_ROLLBACK_LIST4args'>
          <sourcecode type='xdr'>
/// struct ROLLBACK_LIST4args {
///     /* CURRENT_FH: file */
///     stateid4        ria_stateid;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='ROLLBACK_LIST4res' numbered='true' removeInRFC='false' toc='exclude'>
        <name>RESULTS</name>
        <figure anchor='code_rollback_info4'>
          <sourcecode type='xdr'>
/// struct rollback_info4 {
///     uint32_t       ri_client_id;
///     nfs_fh4        ri_fh;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_ROLLBACK_LIST4resok'>
          <sourcecode type='xdr'>
/// struct ROLLBACK_LIST4resok {
///     rollback_info4  rlr_rollbacks&lt;&gt;;
/// };
          </sourcecode>
        </figure>

        <figure anchor='code_ROLLBACK_LIST4res'>
          <sourcecode type='xdr'>
/// union ROLLBACK_LIST4res switch (nfsstat4 rlr_status) {
///     case NFS4_OK:
///         ROLLBACK_LIST4resok         rlr_resok4;
///     default:
///         void;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='ROLLBACK_LIST4_desc' numbered='true' removeInRFC='false' toc='exclude'>
        <name>DESCRIPTION</name>
        <t>
          ROLLBACK_LIST is a new operation to list the open client rollback files
          for the current filehandle.
          As shown in <xref target='code_ROLLBACK_LIST4args' />, a stateid
          that follows the rules of <xref target='RESERVE4_desc' /> <bcp14>MUST</bcp14>
          be presented.
        </t>
        <t>
          The result is an array of rollback_info4 (see <xref target='code_rollback_info4' />).
          The ri_client_id allows the metadata
          server to determine which reservations belonged to a dead client.
          The ffv2_key4 associated with the reservation file <bcp14>MUST NOT</bcp14>
          be sent back in the results.
        </t>
      </section>
    </section>

    <section anchor='RESERVE_RECOVER' numbered='true' removeInRFC='false' toc='default'>
      <name>Operation 79: RESERVE_RECOVER - Get information on a byte range for writing</name>
      <section anchor='RESERVE_RECOVER4args' numbered='true' removeInRFC='false' toc='exclude'>
        <name>ARGUMENTS</name>
        <figure anchor='code_RESERVE_RECOVER4args'>
          <sourcecode type='xdr'>
/// struct RESERVE_RECOVER4args {
///     /* CURRENT_FH: file */
///     stateid4        rra_stateid;
///     uint32_t        rra_reservation_id;
///     ffv2_key4       rra_key;
///     clientid4       rra_client_id;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='RESERVE_RECOVER4res' numbered='true' removeInRFC='false' toc='exclude'>
        <name>RESULTS</name>

        <figure anchor='code_RESERVE_RECOVER4res'>
          <sourcecode type='xdr'>
/// struct RESERVE_RECOVER4res {
///     nfsstat4 rrr_status;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='RESERVE_RECOVER4_desc' numbered='true' removeInRFC='false' toc='exclude'>
        <name>DESCRIPTION</name>
        <t>
          RESERVE_RECOVER is a new operation to recover a reservation on a file. The
          user has to have access to the underlying file in order to recover
          the reservation. For the given reservation identified by rra_reservation_id
          (see <xref target='code_RESERVE_RECOVER4args' />), the rra_key <bcp14>MUST</bcp14>
          match that which was persisted in the original RESERVE operation to create the
          reservation. The rra_client_id will only match if it is the original client
          which has not restarted. In any event, upon successful recovery, the rra_client_id
          is persisted for the next time ROLLBACK_LIST is presented to the server.
          As shown in <xref target='code_RESERVE_RECOVER4args' />, a stateid
          that follows the rules of <xref target='RESERVE4_desc' /> <bcp14>MUST</bcp14>
          be presented.
        </t>
        <t>
          If there is no matching reservation for the rra_reservation_id, then
          the server <bcp14>MUST</bcp14> send back the error NFS4ERR_NOENT. If the
          rra_key does not match that peristed, then the server <bcp14>MUST</bcp14> send back the error
          NFS4ERR_PERM. The client can use GETATTR to determine if this was due
          to normal file system semantics or a mismatched ffv2_key4.
        </t>
      </section>
    </section>

    <section anchor='RESERVE_RELEASE' numbered='true' removeInRFC='false' toc='default'>
      <name>Operation 80: RESERVE_RELEASE - Release reservation on a byte range for writing</name>
      <section anchor='RESERVE_RELEASE4args' numbered='true' removeInRFC='false' toc='exclude'>
        <name>ARGUMENTS</name>
        <figure anchor='code_RESERVE_RELEASE4args'>
          <sourcecode type='xdr'>
/// struct RESERVE_RELEASE4args {
///     /* CURRENT_FH: file */
///     stateid4        rra_stateid;
///     uint32_t        rra_reservation_id;
///     ffv2_key4       rra_key;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='RESERVE_RELEASE4res' numbered='true' removeInRFC='false' toc='exclude'>
        <name>RESULTS</name>

        <figure anchor='code_RESERVE_RELEASE4res'>
          <sourcecode type='xdr'>
/// struct RESERVE_RELEASE4res {
///     nfsstat4 rrr_status;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='RESERVE_RELEASE4_desc' numbered='true' removeInRFC='false' toc='exclude'>
        <name>DESCRIPTION</name>
        <t>
          RESERVE_RELEASE is a new operation to release a reservation on a file. The
          user has to have access to the underlying file in order to release
          the reservation. For the given reservation identified by rra_reservation_id
          (see <xref target='code_RESERVE_RELEASE4args' />), the rra_key <bcp14>MUST</bcp14>
          match that which was persisted in the original RESERVE operation to create the
          reservation.
          As shown in <xref target='code_RESERVE_RELEASE4args' />, a stateid
          that follows the rules of <xref target='RESERVE4_desc' /> <bcp14>MUST</bcp14>
          be presented.
        </t>
        <t>
          If there is no matching reservation for the rra_reservation_id, then
          the server <bcp14>MUST</bcp14> send back the error NFS4ERR_NOENT. If the
          rra_key does not match that peristed, then the server <bcp14>MUST</bcp14> send back the error
          NFS4ERR_PERM. The client can use GETATTR to determine if this was due
          to normal file system semantics or a mismatched ffv2_key4.
        </t>
        <t>
          The state of fattr4reserved_state for the reservation file <bcp14>MUST</bcp14>
          be persisted to NFS4_RESERVED_RELEASED.
        </t>
      </section>
    </section>
  </section>

  <section anchor='cb_ops' numbered='true' removeInRFC='false' toc='default'>
    <name>New NFSv4.2 Callback Operations</name>
    <section anchor='CB_RESERVE_REPAIR' numbered='true' removeInRFC='false' toc='default'>
      <name>Operation 16: CB_RESERVE_REPAIR - Repair a reservation of a byte range for writing</name>
      <section anchor='CB_RESERVE_REPAIR4args' numbered='true' removeInRFC='false' toc='exclude'>
        <name>ARGUMENTS</name>
        <figure anchor='code_CB_RESERVE_REPAIR4args'>
          <sourcecode type='xdr'>
/// struct CB_RESERVE_REPAIR4args {
///     /* CURRENT_FH: file */
///     stateid4             crra_stateid;
///     uint32_t             crra_reservation_id;
///     ffv2_key4            crra_key;
///     ffv2_encoding_type4  crra_type;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='CB_RESERVE_REPAIR4res' numbered='true' removeInRFC='false' toc='exclude'>
        <name>RESULTS</name>

        <figure anchor='code_CB_RESERVE_REPAIR4res'>
          <sourcecode type='xdr'>
/// struct CB_RESERVE_REPAIR4res {
///     nfsstat4 crrr_status;
/// };
          </sourcecode>
        </figure>
      </section>

      <section anchor='CB_RESERVE_REPAIR4_desc' numbered='true' removeInRFC='false' toc='exclude'>
        <name>DESCRIPTION</name>
        <t>
          CB_RESERVE_REPAIR is a new callback operation to request that the client repair a reservation
          on a file. The user has to have access to the underlying file in order to release
          the reservation. For the given reservation identified by rra_reservation_id
          (see <xref target='code_CB_RESERVE_REPAIR4args' />), the crra_key <bcp14>MUST</bcp14>
          match that which was persisted in the original RESERVE operation to create the
          reservation.
          As shown in <xref target='code_CB_RESERVE_REPAIR4args' />, a stateid
          that follows the rules of <xref target='RESERVE4_desc' /> <bcp14>MUST</bcp14>
          be presented.
        </t>
        <t>
          If the client does not support the RESERVE family of operations, it
          <bcp14>MUST</bcp14> return an error of NFS4ERR_NOTSUPP. Note that
          this is most likely going to occur as in this case it will not
          support CB_RESERVE_REPAIR. If the client does not support the
          crra_type for the erasure encoding type, then it <bcp14>MUST</bcp14>
          return an error of NFS4ERR_ENCODING_NOT_SUPPORTED.
        </t>
      </section>
    </section>
  </section>

  <section anchor='xdr_desc' numbered='true' removeInRFC='false' toc='default'>
    <name>Extraction of XDR</name>
    <t>
      This document contains the external data representation (XDR)
      <xref target='RFC4506' /> description of
      the Flexible File Version 2 Layout Type.  The XDR description is embedded in this
      document in a way that makes it simple for the reader to extract
      into a ready-to-compile form.  The reader can feed this document
      into the following shell script to produce the machine readable
      XDR description of the new flags:
    </t>
    <sourcecode type='xdr'>
#!/bin/sh
grep '^ *///' $* | sed 's?^ */// ??' | sed 's?^ *///$??'
    </sourcecode>
    <t>
      That is, if the above script is stored in a file called 'extract.sh', and
      this document is in a file called 'spec.txt', then the reader can do:
    </t>
    <sourcecode type='xdr'>
sh extract.sh &lt; spec.txt &gt; erasure_coding_prot.x
    </sourcecode>
    <t>
      The effect of the script is to remove leading white space from each
      line, plus a sentinel sequence of '///'.  XDR descriptions with the
      sentinel sequence are embedded throughout the document.
    </t>
    <t>
      Note that the XDR code contained in this document depends on types
      from the NFSv4.2 nfs4_prot.x file (generated from
      <xref target='RFC7863' />)
      and the Flexible File Layout Type flexfiles.x file (generated from
      <xref target='RFC8435' />).
      This includes both nfs types that end with a 4, such as offset4,
      length4, etc., as well as more generic types such as uint32_t and
      uint64_t.
    </t>
    <t>
      While the XDR can be appended to that from
      <xref target='RFC7863' />,
      the various code snippets belong in their respective areas of
      that XDR.
    </t>
  </section>

  <section anchor='sec_security' numbered='true' removeInRFC='false' toc='default'>
    <name>Security Considerations</name>
    <t>
      This document has the same security considerations as both Flexible File
      Layout Type version 1 (see Section 15 of <xref target='RFC8435' />)
      and NFSv4.2 (see Section 17 of <xref target='RFC7862' />).
    </t>
  </section>

  <section anchor='sec_iana' numbered='true' removeInRFC='false' toc='default'>
    <name>IANA Considerations</name>

    <section anchor='sec_iana_layouts' numbered='true' removeInRFC='false' toc='default'>
      <name>pNFS Layout Types Registry</name>
      <t>
        <xref target='RFC8881' />
        introduced the 'pNFS Layout Types Registry'; new layout type
        numbers in this registry need to be assigned by IANA.  This document
        defines the protocol associated with an existing layout type number:
        LAYOUT4_FLEX_FILES_V2 (see <xref target='layoutlist' />).
      </t>

      <table anchor='layoutlist'>
        <name>Layout Type Assignments</name>
        <thead>
          <tr>
            <th>Layout Type Name</th>
            <th>Value</th>
            <th>RFC</th>
            <th>How</th>
            <th>Minor Versions</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>LAYOUT4_FLEX_FILES_V2</td> <td>0x6</td> <td>RFCTBD10</td> <td>L</td> <td>1</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section anchor='sec_iana_recallable' numbered='true' removeInRFC='false' toc='default'>
      <name>NFSv4 Recallable Object Types Registry</name>
      <t>
        <xref target='RFC8881' /> also
        introduced the 'NFSv4 Recallable Object Types Registry'.  This document
        defines new recallable objects for RCA4_TYPE_MASK_FFV2_LAYOUT_MIN and
        RCA4_TYPE_MASK_FFV2_LAYOUT_MAX (see <xref target='recalllist' />).
      </t>

      <table anchor='recalllist'>
        <name>Recallable Object Type Assignments</name>
        <thead>
          <tr>
            <th>Recallable Object Type Name</th>
            <th>Value</th>
            <th>RFC</th>
            <th>How</th>
            <th>Minor Versions</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>RCA4_TYPE_MASK_FFV2_LAYOUT_MIN</td> <td>20</td> <td>RFCTBD10</td> <td>L</td> <td>1</td>
          </tr>
          <tr>
            <td>RCA4_TYPE_MASK_FFV2_LAYOUT_MAX</td> <td>21</td> <td>RFCTBD10</td> <td>L</td> <td>1</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section anchor='sec_iana_encoding' numbered='true' removeInRFC='false' toc='default'>
      <name>Flexible File Version 2 Layout Type Erasure Encoding Type Registry</name>
      <t>
        This document introduces the 'Flexible File Version 2 Layout Type Erasure Encoding Type Registry'. This
        document defines the FFV2_ENCODING_MIRRORED type for Client-Side Mirroring
        (see <xref target='erasure_encoding' />).
      </t>

      <table anchor='erasure_encoding'>
        <name>Flexible File Version 2 Layout Type Erasure Encoding Type Assignments</name>
        <thead>
          <tr>
            <th>Erasure Encoding Type Name</th>
            <th>Value</th>
            <th>RFC</th>
            <th>How</th>
            <th>Minor Versions</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>FFV2_ENCODING_MIRRORED</td> <td>1</td> <td>RFCTBD10</td> <td>L</td> <td>2</td>
          </tr>
        </tbody>
      </table>
    </section>
  </section>

</middle>

<back>

<references>
  <name>References</name>

  <references>
  <name>Normative References</name>
    <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
       href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml'/>
    <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
       href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4506.xml'/>
    <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
       href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7530.xml'/>
    <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
       href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7862.xml'/>
    <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
       href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7863.xml'/>
    <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
       href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml'/>
    <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
       href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8178.xml'/>
    <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
       href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8435.xml'/>
    <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
       href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8881.xml'/>
  </references>

  <references>
  <name>Informative References</name>
    <xi:include xmlns:xi='http://www.w3.org/2001/XInclude'
       href='https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1813.xml'/>
    <reference anchor='Plank97' target='http://web.eecs.utk.edu/~jplank/plank/papers/CS-96-332.html'>
      <front>
        <title>A Tutorial on Reed-Solomon Coding for Fault-Tolerance in RAID-like System</title>
        <author fullname='James S. Plank' initials='J.' surname='Plank'>
        </author>
        <date month='September' year='1997'/>
      </front>
    </reference>
  </references>
</references>

<section numbered='true' removeInRFC='false' toc='default'>
  <name>Acknowledgments</name>
  <t>
    The following from Hammerspace were instrumental in driving
    Flexible File Version 2 Layout Type: David Flynn, Trond Myklebust,
    Tom Haynes, Didier Feron,
    Jean-Pierre Monchanin, Pierre Evenou, and Brian Pawlowski.
  </t>
  <t>
    Christoph Helwig was instrumental in making sure Flexible File
    Version 2 Layout Type
    was applicable to more than one Erasure Encoding Type.
  </t>
  <t>
    Robin Battey reviewed the Erasure Encoding approach
    and provided expert feedback.
  </t>
</section>

</back>

</rfc>
