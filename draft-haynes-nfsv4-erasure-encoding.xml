<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE rfc SYSTEM "rfc2629-xhtml.ent">
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>

<rfc
 category="std"
 docName="draft-haynes-nfsv4-erasure-encoding-VERSIONVAR"
 ipr="trust200902"
 obsoletes=""
 scripts="Common,Latin"
 sortRefs="true"
 submissionType="IETF"
 symRefs="true"
 tocDepth="3"
 tocInclude="true"
 version="3"
 xml:lang="en">

<front>
  <title abbrev="erasure-encoding">
    Erasure Encoding of Files in NFSv4.2
  </title>
  <seriesInfo name="Internet-Draft" value="draft-haynes-nfsv4-erasure-encoding-VERSIONVAR"/>
  <author fullname="Thomas Haynes" initials="T." surname="Haynes">
    <organization abbrev="Hammerspace">Hammerspace</organization>
    <address>
      <email>loghyr@hammerspace.com</email>
    </address>
  </author>
  <date year="YEARVAR" month="MONTHVAR" day="DAYVAR"/>
  <area>Transport</area>
  <workgroup>Network File System Version 4</workgroup>
  <keyword>NFSv4</keyword>
  <abstract>
    <t>
      Parallel NFS (pNFS) allows a separation between the metadata (onto
      a metadata server) and data (onto a storage device) for a file.
      The flexible file layout type version 2 is defined in this document
      as an extension to pNFS that allows the use of storage devices that
      require only a limited degree of interaction with the metadata
      server and use already-existing protocols.  Data replication is
      also added to provide integrity.
    </t>
  </abstract>

  <note removeInRFC="true">
    <t>
      Discussion of this draft takes place
      on the NFSv4 working group mailing list (nfsv4@ietf.org),
      which is archived at
      <eref target="https://mailarchive.ietf.org/arch/browse/nfsv4/"/>.
      Working Group information can be found at
      <eref target="https://datatracker.ietf.org/wg/nfsv4/about/"/>.
    </t>
  </note>
</front>

<middle>

  <section anchor="sec_intro" numbered="true" removeInRFC="false" toc="default">
    <name>Introduction</name>
    <t>
      In Parallel NFS (pNFS), the metadata server returns layout type
      structures that describe where file data is located.  There are
      different layout types for different storage systems and methods
      of arranging data on storage devices.  <xref target="RFC8435"
      format="default" sectionFormat="of" /> defined the flexible
      file layout type used with file-based data servers that are
      accessed using the NFS protocols: NFSv3 <xref target="RFC1813"
      format="default" sectionFormat="of" />, NFSv4.0 <xref
      target="RFC7530" format="default" sectionFormat="of" />, NFSv4.1
      <xref target="RFC8881" format="default" sectionFormat="of" />, and
      NFSv4.2 <xref target="RFC7862" format="default" sectionFormat="of" />.
    </t>

    <t>
      The Client Side Mirroring (see Section 8 of <xref target="RFC8435"
      format="default" sectionFormat="of"/>), introduced with the first
      version of the flex file layout type, provides for replication
      of data but does not provide for integerity of data. In the event
      of an error, an user would be able to repair the file by resilvering
      the mirror contents. I.e., they would pick one of the mirror
      instances and replicate it to the other instance locations.
    </t>

    <t>
      However, lacking integrity checks, silent corruptions are not able
      to be detected and the choice of what consititues the good copy
      is difficult.  This document updates the flexible file layout type to version 2
      by providing data integrity for erasure encoding.
    </t>

    <t>
      Using the process detailed in <xref target="RFC8178" format="default"
      sectionFormat="of"/>, the revisions in this document become an
      extension of NFSv4.2 <xref target="RFC7862" format="default"
      sectionFormat="of"/>. They are built on top of the external data
      representation (XDR) <xref target="RFC4506" format="default"
      sectionFormat="of"/> generated from <xref target="RFC7863"
      format="default" sectionFormat="of"/>.
    </t>

    <section anchor="sec_defs" numbered="true" removeInRFC="false" toc="default">
      <name>Definitions</name>
      <dl newline="false" spacing="normal">
        <dt>Client Side Mirroring:</dt>
        <dd>
          A file based replication method where copies are maintained
          in parallel.
        </dd>

        <dt>Erasure Encoding:</dt>
        <dd>
          A file based replication method where copies are maintained
          in parallel.
        </dd>

        <dt>integrity of data:</dt>
        <dd>
          Data integrity refers to the accuracy, consistency, and
          reliability of data throughout its lifecycle.
        </dd>

        <dt>non-systematic encoding:</dt>
        <dd>
        </dd>

        <dt>replication of data:</dt>
        <dd>
        </dd>

        <dt>systematic encoding:</dt>
        <dd>
        </dd>
      </dl>
    </section>

    <section numbered="true" removeInRFC="false" toc="default">
      <name>Requirements Language</name>
      <t>
        The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>",
        "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL
        NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>",
        "<bcp14>RECOMMENDED</bcp14>", "<bcp14>NOT RECOMMENDED</bcp14>",
        "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this
        document are to be interpreted as described in BCP&nbsp;14 <xref
        target="RFC2119" format="default" sectionFormat="of"/> <xref
        target="RFC8174" format="default" sectionFormat="of"/> when,
        and only when, they appear in all capitals, as shown here.
      </t>
    </section>
  </section>

  <section numbered="true" removeInRFC="false" toc="default">
    <name>Flexible File Layout Type Version 2</name>

    <t>
      The original layouttype4 introduced in <xref target="RFC8881"
      format="default" sectionFormat="of" /> is modified to as in <xref
      target='code_layout4' />.
    </t>

    <figure anchor='code_layout4'>
      <sourcecode type='xdr'>
       enum layouttype4 {
           LAYOUT4_NFSV4_1_FILES   = 1,
           LAYOUT4_OSD2_OBJECTS    = 2,
           LAYOUT4_BLOCK_VOLUME    = 3,
           LAYOUT4_FLEX_FILES      = 4,
           LAYOUT4_FLEX_FILES_V2   = 5
       };

       struct layout_content4 {
           layouttype4             loc_type;
           opaque                  loc_body&lt;&gt;;
       };

       struct layout4 {
           offset4                 lo_offset;
           length4                 lo_length;
           layoutiomode4           lo_iomode;
           layout_content4         lo_content;
       };
      </sourcecode>
    </figure>

    <t>
      This document defines structures associated with the layouttype4
      value LAYOUT4_FLEX_FILES_V2.  <xref target="RFC8881" format="default"
      sectionFormat="of" /> specifies the loc_body structure as an XDR
      type "opaque".  The opaque layout is uninterpreted by the generic
      pNFS client layers but is interpreted by the flexible file layout
      type implementation.  This section defines the structure of this
      otherwise opaque value, ffv2_layout4.
    </t>

    <section anchor="ffv2_encoding_type" numbered="true" removeInRFC="false" toc="default">
      <name>ffv2_layout4</name>

      <figure anchor='code_ffv2_encoding_type'>
        <sourcecode type='xdr'>
   /// enum ffv2_encoding_type {
   ///     FFV2_ENCODING_TYPE_MIRRORED       = 0x1;
   /// };
        </sourcecode>
      </figure>

      <t>
        The ffv2_encoding_type (see <xref target='code_ffv2_encoding_type' />)
        encompasses a new IANA registry for "Flex Files V2 Erasure
        Encoding Type Registry" (see <xref target='sec_iana_encoding' />).
        I.e., instead of defining a new Layout Type for each
        Erasure Encoding, we define a new Erasure Encoding Type.
        Except for FFV2_ENCODING_TYPE_MIRRORED, each of the types
        is expected to employ the new operations in this documement.
      </t>

      <t>
        FFV2_ENCODING_TYPE_MIRRORED offers replication of data and
        not integrity of data. As such, it does not need operations
        like WRITE_LOG (see <xref target='WRITE_LOG' />).
      </t>
    </section>

    <section anchor="ffv2_layout" numbered="true" removeInRFC="false" toc="default">
      <name>ffv2_layout4</name>

      <figure anchor='code_ffv2_layout4'>
        <sourcecode type='xdr'>
   /// const FF_FLAGS_NO_LAYOUTCOMMIT   = 0x00000001;
   /// const FF_FLAGS_NO_IO_THRU_MDS    = 0x00000002;
   /// const FF_FLAGS_NO_READ_IO        = 0x00000004;
   /// const FF_FLAGS_WRITE_ONE_MIRROR  = 0x00000008;

   /// typedef uint32_t            ff_flags4;
   ///

   /// /*
   ///  * NFsv4.0, NFSv4.1, and NFSv4.2 can all
   ///  * have unique stateids for the file.
   ///  */
   /// struct ffv2_file_info4 {
   ///     stateid4                fffi_stateid;
   ///     nfs_fh4                 fffi_fh_vers;
   /// };
   ///
   /// const FFV2_DS_FLAGS_ACTIVE        = 0x00000001;
   /// const FFV2_DS_FLAGS_SPARE         = 0x00000002;
   /// const FFV2_DS_FLAGS_REPAIR        = 0x00000004;
   /// typedef uint32_t            ffv2_ds_flags4;
   ///
   /// struct ffv2_data_server4 {
   ///     deviceid4               ffds_deviceid;
   ///     uint32_t                ffds_efficiency;
   ///     ffv2_file_info4         ffds_file_info&lt;&gt;;
   ///     fattr4_owner            ffds_user;
   ///     fattr4_owner_group      ffds_group;
   ///     ffv2_ds_flags4          ffds_flags;
   /// };
   ///
   /// struct ffv2_mirror4 {
   ///     ffv2_data_server4       ffm_data_servers&lt;&gt;;
   ///     ffv2_encoding_type      ffds_encoding;
   /// };
   ///
   /// union ffv2_encoding_data switch
   ///         (ffv2_encoding_type fed_type) {
   ///     case FF2_ENCODING_TYPE_MIRRORED:
   ///         void;
   /// };
   ///
   /// struct ffv2_layout4 {
   ///     length4                 ffl_stripe_unit;
   ///     ffv2_mirror4            ffl_mirrors&lt;&gt;;
   ///     ff_flags4               ffl_flags;
   ///     uint32_t                ffl_stats_collect_hint;
   /// };
   ///
        </sourcecode>
      </figure>
    </section>
  </section>

  <section anchor="sec_erasure_encoding" numbered="true" removeInRFC="false" toc="default">
    <name>Erasure Encoding</name>
    <t>
      Erasure Encoding takes an user data block and transforms it to
      send to the data servers (see <xref target='encoding' />). It
      generates a projection header and payload. The header is metadata
      information for the payload being sent to each data server. The
      change_id is an unique identifier generated by the client to describe
      the current write transaction. The client_id is an unique identifier
      assigned by the metadata server to describe which client is making
      the current write transaction. The id describes XXX. The eff_len
      is the length of the data within the block. Finally, the crc32 is
      the 32 bit crc calculation of the projection header (with the crc32
      field being 0) and the projection payload. By combining the two
      parts of the projection, integrity is ensured for both the
      parts.
    </t>

    <figure anchor='encoding'>
      <artwork>
                      +-----------------+
                      | user data block |
                      +-----------------+
                      |                 |
                      | 3kB data        |
                      |                 |
                      +-----------------+
                      | 1kB empty       |
                      +-------+---------+
                              |
                              |
       +----------------------+-----------------------+
       |        Erasure Encoding Transform Forward    |
       +----+-------------------------------------+---+
            |                                     |
            |                                     |
            |                                     |
        +---+----------------+         +----------+---------+
        | PROJECTION HEADER  |         | PROJECTION HEADER  |
        +--------------------+         +--------------------+
        | change_id: 1       |         | change_id: 1       |
        | client_id: 6       |         | client_id: 6       |
        | id       : 0       |         | id       : 5       |
        | eff_len  : 3kB     |  ...    | eff_len  : 3kB     |
        | crc32    :         |         | crc32    :         |
        +--------------------+         +--------------------+
        | PROJECTION PAYLOAD |         | PROJECTION PAYLOAD |
        +--------------------+         +--------------------+
        | Data               |         | Data               |
        +--------------------+         +--------------------+
             Data Server 1                 Data Server 6
      </artwork>
    </figure>

    <figure anchor='decoding'>
      <artwork>
             Data Server 1                 Data Server 6
        +--------------------+         +--------------------+
        | PROJECTION HEADER  |         | PROJECTION HEADER  |
        +--------------------+         +--------------------+
        | change_id: 1       |         | change_id: 1       |
        | client_id: 6       |         | client_id: 6       |
        | id       : 0       |         | id       : 5       |
        | eff_len  : 3kB     |  ...    | eff_len  : 3kB     |
        | crc32    :         |         | crc32    :         |
        +--------------------+         +--------------------+
        | PROJECTION PAYLOAD |         | PROJECTION PAYLOAD |
        +--------------------+         +--------------------+
        | Data               |         | Data               |
        +---+----------------+         +----------+---------+
            |                                     |
            |                                     |
            |                                     |
       +----+-------------------------------------+---+
       |        Erasure Encoding Transform Reverse    |
       +----------------------+-----------------------+
                              |
                              |
                      +-------+---------+
                      | user data block |
                      +-----------------+
                      |                 |
                      | 3kB data        |
                      |                 |
                      +-----------------+
                      | 1kB empty       |
                      +-----------------+
      </artwork>
    </figure>
  </section>

  <section anchor="block_owner" numbered="true" removeInRFC="false" toc="default">
    <name>Block Owner</name>

    <figure anchor='code_block_owner4'>
      <sourcecode type='xdr'>
/// struct block_owner4 {
///     changeid4   bo_change_id;
///     clientid4   bo_client_id;
///     bool        bo_logged;
/// };
      </sourcecode>
    </figure>

    <t>
      The block_owner4 (see <xref target='code_block_owner4' />)
      is used to determine when and by whom a block was written.
      The bo_client_id <bcp14>MUST</bcp14> be the client id handed out
      by the metadata server to the client as the eir_clientid during
      the EXCHANGE_ID results (see Section 18.35 of <xref target="RFC8881"
      format="default" sectionFormat="of" />)  and <bcp14>MUST NOT</bcp14>
      be the client id supplied by the data server to the client. I.e.,
      across all data files, the bo_client_id uniquely descibes one and
      only one client.
    </t>

    <t>
      The bo_change_id is like the change attribute
      (see Section 5.8.1.4 of <xref target="RFC8881" format="default"
      sectionFormat="of" />) in that each block write by a given
      client has to have an unique bo_change_id. I.e., it can
      be determined which transaction across all data files that
      a block corresponds.
    </t>
  </section>

  <section anchor="WRITE_LOG" numbered="true" removeInRFC="false" toc="default">
    <name>WRITE_LOG</name>
    <t>
      WRITE_LOG is WRITE (see Section 18.32 of <xref target="RFC8881"
      format="default" sectionFormat="of" />) with additional semantics
      over the block_owner and the logging of blocks. As such, all of
      the normal semantics of WRITE directly apply.
    </t>

    <figure anchor='code_write_block4'>
      <sourcecode type='xdr'>
/// struct write_block4 {
///     uint32_t        wb_num;
///     uint32_t        wb_id;
///     eff_block_len4  wb_effective_len;
///     uint32_t        wb_crc;
///     opaque          wb_block&lt;&gt;;
/// };
      </sourcecode>
    </figure>

    <figure anchor='code_WRITE_LOG4args'>
      <sourcecode type='xdr'>
/// struct WRITE_LOG4args {
///     /* CURRENT_FH: file */
///     stateid4        wla_stateid;
///     offset4         wla_offset;
///     stable_how4     wla_stable;
///     block_owner4    wla_owner;
///     write_block4    wla_data&lt;&gt;; 
/// };
      </sourcecode>
    </figure>

    <figure anchor='code_WRITE_LOGGED4resok'>
      <sourcecode type='xdr'>
struct WRITE_LOGGED4resok {
///     count4          wlr_count;  
///     stable_how4     wlr_committed;
///     verifier4       wlr_writeverf;
///     block_owner4    wlr_owners&lt;&gt;; 
/// };
      </sourcecode>
    </figure>

    <figure anchor='code_WRITE_LOG4res'>
      <sourcecode type='xdr'>
/// union WRITE_LOG4res switch (nfsstat4 wlr_status) {
///     case NFS4_OK:
///         WRITE_LOG4resok    wlr_resok4;
///     default:
///         void;
/// };
      </sourcecode>
    </figure>
  </section>

  <section anchor="READ_LOG" numbered="true" removeInRFC="false" toc="default">
    <name>READ_LOG</name>
    <t>
      READ_LOG is READ (see Section 18.22 of <xref target="RFC8881"
      format="default" sectionFormat="of" />) with additional semantics
      over the block_owner and the logging of blocks. As such, all of
      the normal semantics of READ directly apply.
    </t>

    <figure anchor='code_READ_LOG4args'>
      <sourcecode type='xdr'>
/// struct READ_LOG4args {
///     /* CURRENT_FH: file */
///     stateid4    rla_stateid;
///     offset4     rla_offset;
///     count4      rla_count;
/// };
      </sourcecode>
    </figure>

    <figure anchor='code_read_block4'>
      <sourcecode type='xdr'>
/// struct read_block4 {
///     uint32_t        rb_num;
///     uint32_t        rb_crc;
///     eff_block_len4  rb_effective_len;
///     block_owner4    rb_owner;
///     opaque          rb_block&lt;&gt;;
/// };
      </sourcecode>
    </figure>

    <figure anchor='code_READ_LOG4resok'>
      <sourcecode type='xdr'>
/// struct READ_LOG4resok {
///     bool        rlr_eof;
///     read_block4 rlr_blocks&lt;&gt;;
/// };
      </sourcecode>
    </figure>

    <figure anchor='code_READ_LOG4res'>
      <sourcecode type='xdr'>
/// union READ_LOG4res switch (nfsstat4 rlr_status) {
///     case NFS4_OK:
///          READ_LOG4resok     resok4;
///     default:
///          void;
/// };
      </sourcecode>
    </figure>
  </section>

  <section anchor="READ_BLOCK_LOG" numbered="true" removeInRFC="false" toc="default">
    <name>READ_BLOCK_LOG</name>
    <t>
    </t>

    <figure anchor='code_READ_BLOCK_LOG4args'>
      <sourcecode type='xdr'>
/// struct READ_BLOCK_LOG4args {
///     /* CURRENT_FH: file */
///     stateid4    rbla_stateid;
///     offset4     rbla_offset;
///     count4      rbla_count;
/// };
      </sourcecode>
    </figure>

    <figure anchor='code_read_block_log4'>
      <sourcecode type='xdr'>
/// struct read_block_log4 {
///     uint32_t        rbl_num;
///     block_owner4    rbl_owner;
/// };
      </sourcecode>
    </figure>

    <figure anchor='code_READ_BLOCK_LOG4resok'>
      <sourcecode type='xdr'>
/// struct READ_BLOCK_LOG4resok {
///     bool            rblr_eof;
///     read_block_log4 rblr_blocks&lt;&gt;;
/// };
      </sourcecode>
    </figure>

    <figure anchor='code_READ_BLOCK_LOG4res'>
      <sourcecode type='xdr'>
/// union READ_BLOCK_LOG4res switch (nfsstat4 rblr_status) {
///     case NFS4_OK:
///         READ_LOG4resok     resok4;
///     default:
///         void;
/// };
      </sourcecode>
    </figure>
  </section>

  <section anchor="COMMIT_LOG" numbered="true" removeInRFC="false" toc="default">
    <name>COMMIT_LOG</name>
    <t>
      COMMIT_LOG is COMMIT (see Section 18.3 of <xref target="RFC8881"
      format="default" sectionFormat="of" />) with additional semantics
      over the block_owner and the logging of blocks. As such, all of
      the normal semantics of COMMIT directly apply.
    </t>

    <figure anchor='code_commit_block4'>
      <sourcecode type='xdr'>
/// struct commit_block4 {
///     uint32_t        cb_num;
///     block_owner4    cb_owner;
/// };
      </sourcecode>
    </figure>

    <figure anchor='code_COMMIT_LOG4args'>
      <sourcecode type='xdr'>
/// struct COMMIT_LOG4args {
///     /* CURRENT_FH: file */
///     offset4         cpa_offset;
///     count4          cpa_count;
///     commit_block4   cpa_blocks&lt;&gt;;
/// };
      </sourcecode>
    </figure>

    <figure anchor='code_COMMIT_LOG4resok'>
      <sourcecode type='xdr'>
/// struct COMMIT_LOG4resok {
///     verifier4       writeverf;
/// };
      </sourcecode>
    </figure>

    <figure anchor='code_COMMIT_LOG4res'>
      <sourcecode type='xdr'>
/// union COMMIT_LOG4res switch (nfsstat4 cpr_status) {
///     case NFS4_OK:
///         COMMIT_LOG4resok   resok4;
///     default:
///         void;
/// };
      </sourcecode>
    </figure>
  </section>

  <section anchor="xdr_desc" numbered="true" removeInRFC="false" toc="default">
    <name>Extraction of XDR</name>
    <t>
      This document contains the external data representation (XDR)
      <xref target="RFC4506" format="default" sectionFormat="of"/> description of the uncacheable
      attribute.  The XDR description is embedded in this
      document in a way that makes it simple for the reader to extract
      into a ready-to-compile form.  The reader can feed this document
      into the following shell script to produce the machine readable
      XDR description of the new flags:
    </t>
    <sourcecode type='xdr'>
#!/bin/sh
grep '^ *///' $* | sed 's?^ */// ??' | sed 's?^ *///$??'
    </sourcecode>
    <t>
      That is, if the above script is stored in a file called "extract.sh", and
      this document is in a file called "spec.txt", then the reader can do:
    </t>
    <sourcecode type='xdr'>
sh extract.sh &lt; spec.txt &gt; erasure_coding_prot.x
    </sourcecode>
    <t>
      The effect of the script is to remove leading white space from each
      line, plus a sentinel sequence of "///".  XDR descriptions with the
      sentinel sequence are embedded throughout the document.
    </t>
    <t>
      Note that the XDR code contained in this document depends on types
      from the NFSv4.2 nfs4_prot.x file (generated from
      <xref target="RFC7863" format="default" sectionFormat="of"/>)
      and the Flex Files Layout Type flexfiles.x file (generated from
      <xref target="RFC8435" format="default" sectionFormat="of"/>).
      This includes both nfs types that end with a 4, such as offset4,
      length4, etc., as well as more generic types such as uint32_t and
      uint64_t.
    </t>
    <t>
      While the XDR can be appended to that from
      <xref target="RFC7863" format="default" sectionFormat="of"/>,
      the various code snippets belong in their respective areas of
      that XDR.
    </t>
  </section>

  <section anchor="sec_security" numbered="true" removeInRFC="false" toc="default">
    <name>Security Considerations</name>
    <t>
    </t>
  </section>

  <section anchor="sec_iana" numbered="true" removeInRFC="false" toc="default">
    <name>IANA Considerations</name>

    <section anchor="sec_iana_layouts" numbered="true" removeInRFC="false" toc="default">
      <name>pNFS Layout Types Registry</name>
      <t>
        <xref target="RFC8881" format="default" sectionFormat="of" />
        introduced the "pNFS Layout Types Registry"; new layout type
        numbers in this registry need to be assigned by IANA.  This document
        defines the protocol associated with an existing layout type number:
        LAYOUT4_FLEX_FILES_V2 (see <xref target='layoutlist' />).
      </t>

      <table anchor="layoutlist">
        <name>Layout Type Assignments</name>
        <thead>
          <tr>
            <th>Layout Type Name</th>
            <th>Value</th>
            <th>RFC</th>
            <th>How</th>
            <th>Minor Versions</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>LAYOUT4_FLEX_FILES_V2</td> <td>0x6</td> <td>RFCTBD10</td> <td>L</td> <td>1</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section anchor="sec_iana_recallable" numbered="true" removeInRFC="false" toc="default">
      <name>NFSv4 Recallable Object Types Registry</name>
      <t>
        <xref target="RFC8881" format="default" sectionFormat="of" /> also
        introduced the "NFSv4 Recallable Object Types Registry".  This document
        defines new recallable objects for RCA4_TYPE_MASK_FF2_LAYOUT_MIN and
        RCA4_TYPE_MASK_FF2_LAYOUT_MAX (see <xref target='recalllist' />).
      </t>

      <table anchor="recalllist">
        <name>Recallable Object Type Assignments</name>
        <thead>
          <tr>
            <th>Recallable Object Type Name</th>
            <th>Value</th>
            <th>RFC</th>
            <th>How</th>
            <th>Minor Versions</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>RCA4_TYPE_MASK_FF2_LAYOUT_MIN</td> <td>20</td> <td>RFCTBD10</td> <td>L</td> <td>1</td>
          </tr>
          <tr>
            <td>RCA4_TYPE_MASK_FF2_LAYOUT_MAX</td> <td>21</td> <td>RFCTBD10</td> <td>L</td> <td>1</td>
          </tr>
        </tbody>
      </table>
    </section>

    <section anchor="sec_iana_encoding" numbered="true" removeInRFC="false" toc="default">
      <name>Flex Files V2 Erasure Encoding Type Registry</name>
      <t>
        This document introduces the "Flex Files V2 Erasure Encoding Type Registry". This
        document defines the FF2_ENCODING_TYPE_MIRRORED type for Client-Side Mirroring
        (see <xref target='erasure_encoding' />).
      </t>

      <table anchor="erasure_encoding">
        <name>Flex Files V2 Erasure Encoding Type Assignments</name>
        <thead>
          <tr>
            <th>Erasure Encoding Type Name</th>
            <th>Value</th>
            <th>RFC</th>
            <th>How</th>
            <th>Minor Versions</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>FF2_ENCODING_TYPE_MIRRORED</td> <td>1</td> <td>RFCTBD10</td> <td>L</td> <td>1</td>
          </tr>
        </tbody>
      </table>
    </section>
  </section>

</middle>

<back>

<references>
  <name>References</name>

  <references>
  <name>Normative References</name>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4506.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7530.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7862.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7863.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8174.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8178.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8435.xml"/>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8881.xml"/>
  </references>

  <references>
  <name>Informative References</name>
    <xi:include xmlns:xi="http://www.w3.org/2001/XInclude"
       href="https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1813.xml"/>
  </references>
</references>

<section numbered="true" removeInRFC="false" toc="default">
  <name>Acknowledgments</name>
  <t>
    The following from Hammerspace were instrumental in driving
    Flex Files v2: David Flynn, Trond Myklebust, Tom Haynes, Didier Feron,
    Jean-Pierre Monchanin, Pierre Evenou, and Brian Pawlowski.
  </t>
  <t>
    Christoph Helwig was instrumental in making sure Flex Files v2
    was applicable to more than one Erasure-Encoding Type.
  </t>
</section>

<section numbered="true" removeInRFC="true" toc="default">
  <name>RFC Editor Notes</name>

  <t>
    [RFC Editor: prior to publishing this document as an RFC, please
    replace all occurrences of RFCTBD10 with RFCxxxx where xxxx is the
    RFC number of this document]
  </t>
</section>

</back>

</rfc>
